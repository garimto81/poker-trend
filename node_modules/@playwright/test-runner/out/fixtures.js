"use strict";
/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FixturePool = exports.assignConfig = exports.config = exports.setParameterValues = exports.matrix = exports.assignParameters = exports.parameters = exports.parameterRegistrations = exports.currentTestInfo = exports.setCurrentTestInfo = void 0;
const debug_1 = require("./debug");
let currentTestInfoValue = null;
function setCurrentTestInfo(testInfo) {
    currentTestInfoValue = testInfo;
}
exports.setCurrentTestInfo = setCurrentTestInfo;
function currentTestInfo() {
    return currentTestInfoValue;
}
exports.currentTestInfo = currentTestInfo;
exports.parameterRegistrations = new Map();
exports.parameters = {};
function assignParameters(params) {
    exports.parameters = Object.assign(exports.parameters, params);
}
exports.assignParameters = assignParameters;
exports.matrix = {};
function setParameterValues(name, values) {
    if (!(name in exports.matrix))
        throw new Error(`Unregistered parameter '${name}' was set.`);
    exports.matrix[name] = values;
}
exports.setParameterValues = setParameterValues;
exports.config = {};
function assignConfig(c) {
    exports.config = Object.assign(exports.config, c);
}
exports.assignConfig = assignConfig;
class Fixture {
    constructor(pool, registration) {
        this._setup = false;
        this._teardown = false;
        this.pool = pool;
        this.registration = registration;
        this.usages = new Set();
        this.hasGeneratorValue = registration.name in exports.parameters;
        this.value = this.hasGeneratorValue ? exports.parameters[registration.name] : null;
        if (this.hasGeneratorValue && this.registration.deps.length)
            throw new Error(`Parameter fixture "${this.registration.name}" should not have dependencies`);
    }
    async setup() {
        if (this.hasGeneratorValue)
            return;
        for (const name of this.registration.deps) {
            await this.pool.setupFixture(name);
            this.pool.instances.get(name).usages.add(this.registration.name);
        }
        const params = {};
        for (const n of this.registration.deps)
            params[n] = this.pool.instances.get(n).value;
        let setupFenceFulfill;
        let setupFenceReject;
        const setupFence = new Promise((f, r) => { setupFenceFulfill = f; setupFenceReject = r; });
        const teardownFence = new Promise(f => this._teardownFenceCallback = f);
        debug_1.debugLog(`setup fixture "${this.registration.name}"`);
        this._tearDownComplete = this.registration.fn(params, async (value) => {
            this.value = value;
            setupFenceFulfill();
            return await teardownFence;
        }).catch((e) => {
            if (!this._setup)
                setupFenceReject(e);
            else
                throw e;
        });
        await setupFence;
        this._setup = true;
    }
    async teardown() {
        if (this.hasGeneratorValue) {
            this.pool.instances.delete(this.registration.name);
            return;
        }
        if (this._teardown)
            return;
        this._teardown = true;
        for (const name of this.usages) {
            const fixture = this.pool.instances.get(name);
            if (!fixture)
                continue;
            await fixture.teardown();
        }
        if (this._setup) {
            debug_1.debugLog(`teardown fixture "${this.registration.name}"`);
            this._teardownFenceCallback();
            await this._tearDownComplete;
        }
        this.pool.instances.delete(this.registration.name);
    }
}
let lastFixturePoolId = 0;
class FixturePool {
    constructor(parentPool) {
        this.instances = new Map();
        this.parentPool = parentPool;
        this.id = ++lastFixturePoolId;
        this.registrations = new Map(parentPool ? parentPool.registrations : []);
    }
    union(other) {
        const containsRegistrationRecursively = (pool, registration) => {
            if (pool.registrations.get(registration.name) === registration)
                return true;
            if (!pool.parentPool)
                return false;
            return containsRegistrationRecursively(pool.parentPool, registration);
        };
        const result = new FixturePool(this);
        for (const [name, otherRegistration] of other.registrations) {
            const thisRegistration = this.registrations.get(name);
            if (!thisRegistration) {
                result.registrations.set(name, otherRegistration);
            }
            else if (containsRegistrationRecursively(this, otherRegistration)) {
                // |this| contains an override - do nothing.
            }
            else if (containsRegistrationRecursively(other, thisRegistration)) {
                // |other| contains an override - use it.
                result.registrations.set(name, otherRegistration);
            }
            else {
                // Both |this| and |other| have a different override - throw.
                throw new Error(`Fixture "${name}" is defined in both fixture sets.`);
            }
        }
        return result;
    }
    registerFixture(name, scope, fn, auto, isOverride) {
        const previous = this.registrations.get(name);
        if (!isOverride && previous) {
            if (previous.scope !== scope)
                throw new Error(`Fixture "${name}" has already been registered as a ${previous.scope} fixture. Use a different name for this ${scope} fixture.`);
            else
                throw new Error(`Fixture "${name}" has already been registered. Use ${scope === 'test' ? 'overrideTestFixtures' : 'overrideWorkerFixtures'} to override it in a specific test file.`);
        }
        else if (isOverride && !previous) {
            throw new Error(`Fixture "${name}" has not been registered yet. Use ${scope === 'test' ? 'defineTestFixtures' : 'defineWorkerFixtures'} instead.`);
        }
        else if (isOverride && previous && previous.scope !== scope) {
            throw new Error(`Fixture "${name}" is a ${previous.scope} fixture. Use ${previous.scope === 'test' ? 'overrideTestFixtures' : 'overrideWorkerFixtures'} instead.`);
        }
        const deps = fixtureParameterNames(fn);
        const registration = { name, scope, fn, auto, isOverride, deps };
        this.registrations.set(name, registration);
    }
    registerWorkerParameter(parameter) {
        if (exports.parameterRegistrations.has(parameter.name))
            throw new Error(`Parameter "${parameter.name}" has been already registered`);
        exports.parameterRegistrations.set(parameter.name, parameter);
        exports.matrix[parameter.name] = [parameter.defaultValue];
    }
    validate() {
        const markers = new Map();
        const stack = [];
        const visit = (registration) => {
            markers.set(registration, 'visiting');
            stack.push(registration);
            const deps = fixtureParameterNames(registration.fn);
            for (const name of deps) {
                const dep = this.registrations.get(name);
                if (!dep)
                    return `Fixture "${registration.name}" has unknown parameter "${name}".`;
                if (registration.scope === 'worker' && dep.scope === 'test')
                    return `Worker fixture "${registration.name}" cannot depend on a test fixture "${name}".`;
                if (!markers.has(dep)) {
                    const error = visit(dep);
                    if (error)
                        return error;
                }
                else if (markers.get(dep) === 'visiting') {
                    const index = stack.indexOf(dep);
                    const names = stack.slice(index, stack.length).map(r => `"${r.name}"`);
                    return `Fixtures ${names.join(' -> ')} -> "${dep.name}" form a dependency cycle.`;
                }
            }
            markers.set(registration, 'visited');
            stack.pop();
        };
        for (const registration of this.registrations.values()) {
            const error = visit(registration);
            if (error)
                throw new Error(error);
        }
    }
    parametersForFunction(fn, prefix, allowTestFixtures) {
        const result = [];
        const visit = (name, prefix) => {
            const registration = this.registrations.get(name);
            if (!registration)
                return `${prefix} has unknown parameter "${name}".`;
            if (!allowTestFixtures && registration.scope === 'test')
                return `${prefix} cannot depend on a test fixture "${name}".`;
            if (exports.parameterRegistrations.has(name))
                result.push(name);
            for (const dep of registration.deps) {
                const error = visit(dep, `Fixture "${name}"`);
                if (error)
                    return error;
            }
        };
        for (const name of fixtureParameterNames(fn)) {
            const error = visit(name, prefix);
            if (error)
                throw new Error(error);
        }
        for (const registration of this.registrations.values()) {
            if (registration.auto) {
                const error = visit(registration.name, `Fixture "${registration.name}"`);
                if (error)
                    throw new Error(error);
            }
        }
        return result;
    }
    async setupFixture(name) {
        let fixture = this.instances.get(name);
        if (fixture)
            return fixture;
        const registration = this.registrations.get(name);
        if (!registration)
            throw new Error('Unknown fixture: ' + name);
        fixture = new Fixture(this, registration);
        this.instances.set(name, fixture);
        await fixture.setup();
        return fixture;
    }
    async teardownScope(scope) {
        for (const [, fixture] of this.instances) {
            if (fixture.registration.scope === scope)
                await fixture.teardown();
        }
    }
    async resolveParametersAndRunHookOrTest(fn) {
        // Install all automatic fixtures.
        for (const registration of this.registrations.values()) {
            if (registration.auto)
                await this.setupFixture(registration.name);
        }
        // Install used fixtures.
        const names = fixtureParameterNames(fn);
        for (const name of names)
            await this.setupFixture(name);
        const params = {};
        for (const n of names)
            params[n] = this.instances.get(n).value;
        return fn(params);
    }
}
exports.FixturePool = FixturePool;
const signatureSymbol = Symbol('signature');
function fixtureParameterNames(fn) {
    if (!fn[signatureSymbol])
        fn[signatureSymbol] = innerFixtureParameterNames(fn);
    return fn[signatureSymbol];
}
function innerFixtureParameterNames(fn) {
    const text = fn.toString();
    const match = text.match(/(?:async)?(?:\s+function)?[^\(]*\(([^})]*)/);
    if (!match)
        return [];
    const trimmedParams = match[1].trim();
    if (!trimmedParams)
        return [];
    if (trimmedParams && trimmedParams[0] !== '{')
        throw new Error('First argument must use the object destructuring pattern: ' + trimmedParams);
    const signature = trimmedParams.substring(1).trim();
    if (!signature)
        return [];
    return signature.split(',').map((t) => t.trim().split(':')[0].trim());
}
//# sourceMappingURL=fixtures.js.map