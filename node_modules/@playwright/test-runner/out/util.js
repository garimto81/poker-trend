"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.monotonicTime = exports.extractLocation = exports.serializeError = exports.raceAgainstDeadline = void 0;
const path_1 = __importDefault(require("path"));
const util_1 = __importDefault(require("util"));
const stack_utils_1 = __importDefault(require("stack-utils"));
const stackUtils = new stack_utils_1.default();
async function raceAgainstDeadline(promise, deadline) {
    if (!deadline)
        return { result: await promise };
    const timeout = deadline - monotonicTime();
    if (timeout <= 0)
        return { timedOut: true };
    let timer;
    let done = false;
    let fulfill;
    let reject;
    const result = new Promise((f, r) => {
        fulfill = f;
        reject = r;
    });
    setTimeout(() => {
        done = true;
        fulfill({ timedOut: true });
    }, timeout);
    promise.then(result => {
        clearTimeout(timer);
        if (!done) {
            done = true;
            fulfill({ result });
        }
    }).catch(e => {
        clearTimeout(timer);
        if (!done)
            reject(e);
    });
    return result;
}
exports.raceAgainstDeadline = raceAgainstDeadline;
function serializeError(error) {
    if (error instanceof Error) {
        return {
            message: error.message,
            stack: error.stack
        };
    }
    return {
        value: util_1.default.inspect(error)
    };
}
exports.serializeError = serializeError;
function extractLocation(error) {
    const location = stackUtils.parseLine(error.stack.split('\n')[3]);
    return `${path_1.default.resolve(process.cwd(), location.file)}:${location.line}:${location.column}`;
}
exports.extractLocation = extractLocation;
function monotonicTime() {
    const [seconds, nanoseconds] = process.hrtime();
    return seconds * 1000 + (nanoseconds / 1000000 | 0);
}
exports.monotonicTime = monotonicTime;
//# sourceMappingURL=util.js.map