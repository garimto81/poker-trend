/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { expect } from './expect';
import { FixturePool } from './fixtures';
import { TestModifier } from './testModifier';
export declare type Implementation = {
    it: (spec: 'default' | 'skip' | 'only', fixtures: FixturesImpl, ...args: any[]) => void;
    describe: (spec: 'default' | 'skip' | 'only', fixtures: FixturesImpl, ...args: any[]) => void;
    beforeEach: (fixtures: FixturesImpl, fn: Function) => void;
    afterEach: (fixtures: FixturesImpl, fn: Function) => void;
    beforeAll: (fixtures: FixturesImpl, fn: Function) => void;
    afterAll: (fixtures: FixturesImpl, fn: Function) => void;
};
export declare function setImplementation(i: Implementation): void;
interface DescribeHelper<WorkerParameters> {
    describe(name: string, inner: () => void): void;
    describe(name: string, modifierFn: (modifier: TestModifier, parameters: WorkerParameters) => any, inner: () => void): void;
}
declare type DescribeFunction<WorkerParameters> = DescribeHelper<WorkerParameters>['describe'];
interface ItHelper<WorkerParameters, WorkerFixtures, TestFixtures> {
    it(name: string, inner: (fixtures: WorkerParameters & WorkerFixtures & TestFixtures) => Promise<void> | void): void;
    it(name: string, modifierFn: (modifier: TestModifier, parameters: WorkerParameters) => any, inner: (fixtures: WorkerParameters & WorkerFixtures & TestFixtures) => Promise<void> | void): void;
}
declare type ItFunction<WorkerParameters, WorkerFixtures, TestFixtures> = ItHelper<WorkerParameters, WorkerFixtures, TestFixtures>['it'];
declare type It<WorkerParameters, WorkerFixtures, TestFixtures> = ItFunction<WorkerParameters, WorkerFixtures, TestFixtures> & {
    only: ItFunction<WorkerParameters, WorkerFixtures, TestFixtures>;
    skip: ItFunction<WorkerParameters, WorkerFixtures, TestFixtures>;
};
declare type Fit<WorkerParameters, WorkerFixtures, TestFixtures> = ItFunction<WorkerParameters, WorkerFixtures, TestFixtures>;
declare type Xit<WorkerParameters, WorkerFixtures, TestFixtures> = ItFunction<WorkerParameters, WorkerFixtures, TestFixtures>;
declare type Describe<WorkerParameters> = DescribeFunction<WorkerParameters> & {
    only: DescribeFunction<WorkerParameters>;
    skip: DescribeFunction<WorkerParameters>;
};
declare type FDescribe<WorkerParameters> = DescribeFunction<WorkerParameters>;
declare type XDescribe<WorkerParameters> = DescribeFunction<WorkerParameters>;
declare type BeforeEach<WorkerParameters, WorkerFixtures, TestFixtures> = (inner: (fixtures: WorkerParameters & WorkerFixtures & TestFixtures) => Promise<void>) => void;
declare type AfterEach<WorkerParameters, WorkerFixtures, TestFixtures> = (inner: (fixtures: WorkerParameters & WorkerFixtures & TestFixtures) => Promise<void>) => void;
declare type BeforeAll<WorkerFixtures> = (inner: (fixtures: WorkerFixtures) => Promise<void>) => void;
declare type AfterAll<WorkerFixtures> = (inner: (fixtures: WorkerFixtures) => Promise<void>) => void;
export declare class FixturesImpl<WorkerParameters = {}, WorkerFixtures = {}, TestFixtures = {}> {
    it: It<WorkerParameters, WorkerFixtures, TestFixtures>;
    fit: Fit<WorkerParameters, WorkerFixtures, TestFixtures>;
    xit: Xit<WorkerParameters, WorkerFixtures, TestFixtures>;
    test: It<WorkerParameters, WorkerFixtures, TestFixtures>;
    describe: Describe<WorkerParameters>;
    fdescribe: FDescribe<WorkerParameters>;
    xdescribe: XDescribe<WorkerParameters>;
    beforeEach: BeforeEach<WorkerParameters, WorkerFixtures, TestFixtures>;
    afterEach: AfterEach<WorkerParameters, WorkerFixtures, TestFixtures>;
    beforeAll: BeforeAll<WorkerFixtures>;
    afterAll: AfterAll<WorkerFixtures>;
    expect: typeof expect;
    _pool: FixturePool;
    constructor(pool: FixturePool);
    union<P1, W1, T1>(other1: Fixtures<P1, W1, T1>): Fixtures<WorkerParameters & P1, WorkerFixtures & W1, TestFixtures & T1>;
    union<P1, W1, T1, P2, W2, T2>(other1: Fixtures<P1, W1, T1>, other2: Fixtures<P2, W2, T2>): Fixtures<WorkerParameters & P1 & P2, WorkerFixtures & W1 & W2, TestFixtures & T1 & T2>;
    union<P1, W1, T1, P2, W2, T2, P3, W3, T3>(other1: Fixtures<P1, W1, T1>, other2: Fixtures<P2, W2, T2>, other3: Fixtures<P3, W3, T3>): Fixtures<WorkerParameters & P1 & P2 & P3, WorkerFixtures & W1 & W2 & W3, TestFixtures & T1 & T2 & T3>;
    extend<P = {}, W = {}, T = {}>(): Builder<WorkerParameters & P, WorkerFixtures & W, TestFixtures & T>;
    generateParametrizedTests<T extends keyof WorkerParameters>(name: T, values: WorkerParameters[T][]): void;
}
export declare class BuilderImpl<WorkerParameters = {}, WorkerFixtures = {}, TestFixtures = {}> {
    _pool: FixturePool;
    constructor(pool: FixturePool);
    declareTestFixtures<T extends object>(): Builder<WorkerParameters, WorkerFixtures, TestFixtures & T>;
    declareWorkerFixtures<W extends object>(): Builder<WorkerParameters, WorkerFixtures & W, TestFixtures>;
    declareParameters<P extends object>(): Builder<WorkerParameters & P, WorkerFixtures, TestFixtures>;
    defineTestFixture<N extends keyof TestFixtures>(name: N, fixture: (params: WorkerParameters & WorkerFixtures & TestFixtures, runTest: (value: TestFixtures[N]) => Promise<void>) => Promise<void>): void;
    overrideTestFixture<N extends keyof TestFixtures>(name: N, fixture: (params: WorkerParameters & WorkerFixtures & TestFixtures, runTest: (value: TestFixtures[N]) => Promise<void>) => Promise<void>): void;
    defineWorkerFixture<N extends keyof WorkerFixtures>(name: N, fixture: (params: WorkerParameters & WorkerFixtures, runTest: (value: WorkerFixtures[N]) => Promise<void>) => Promise<void>): void;
    overrideWorkerFixture<N extends keyof WorkerFixtures>(name: N, fixture: (params: WorkerParameters & WorkerFixtures, runTest: (value: WorkerFixtures[N]) => Promise<void>) => Promise<void>): void;
    defineParameter<N extends keyof WorkerParameters>(name: N, description: string, defaultValue: WorkerParameters[N]): void;
    build(): Fixtures<WorkerParameters, WorkerFixtures, TestFixtures>;
}
export interface Fixtures<P, W, T> extends FixturesImpl<P, W, T> {
}
export interface Builder<P, W, T> extends BuilderImpl<P, W, T> {
}
export declare const rootFixtures: Fixtures<{}, {}, {}>;
export {};
//# sourceMappingURL=spec.d.ts.map