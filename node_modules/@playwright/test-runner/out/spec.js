"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.rootFixtures = exports.BuilderImpl = exports.FixturesImpl = exports.setImplementation = void 0;
const expect_1 = require("./expect");
const fixtures_1 = require("./fixtures");
Error.stackTraceLimit = 15;
let implementation;
function setImplementation(i) {
    implementation = i;
}
exports.setImplementation = setImplementation;
class FixturesImpl {
    constructor(pool) {
        this._pool = pool;
        this.expect = expect_1.expect;
        this.it = ((...args) => {
            implementation.it('default', this, ...args);
        });
        this.test = this.it;
        this.it.skip = (...args) => implementation.it('skip', this, ...args);
        this.it.only = (...args) => implementation.it('only', this, ...args);
        this.fit = this.it.only;
        this.xit = this.it.skip;
        this.describe = ((...args) => {
            implementation.describe('default', this, ...args);
        });
        this.describe.skip = (...args) => implementation.describe('skip', this, ...args);
        this.describe.only = (...args) => implementation.describe('only', this, ...args);
        this.fdescribe = this.describe.only;
        this.xdescribe = this.describe.skip;
        this.beforeEach = fn => implementation.beforeEach(this, fn);
        this.afterEach = fn => implementation.afterEach(this, fn);
        this.beforeAll = fn => implementation.beforeAll(this, fn);
        this.afterAll = fn => implementation.afterAll(this, fn);
    }
    union(...others) {
        let pool = this._pool;
        for (const other of others)
            pool = pool.union(other._pool);
        pool.validate();
        return new FixturesImpl(pool);
    }
    extend() {
        return new BuilderImpl(new fixtures_1.FixturePool(this._pool));
    }
    generateParametrizedTests(name, values) {
        fixtures_1.setParameterValues(name, values);
    }
}
exports.FixturesImpl = FixturesImpl;
class BuilderImpl {
    constructor(pool) {
        this._pool = pool;
    }
    declareTestFixtures() {
        return this;
    }
    declareWorkerFixtures() {
        return this;
    }
    declareParameters() {
        return this;
    }
    defineTestFixture(name, fixture) {
        this._pool.registerFixture(name, 'test', fixture, name.startsWith('auto'), false);
    }
    overrideTestFixture(name, fixture) {
        this._pool.registerFixture(name, 'test', fixture, name.startsWith('auto'), true);
    }
    defineWorkerFixture(name, fixture) {
        this._pool.registerFixture(name, 'worker', fixture, name.startsWith('auto'), false);
    }
    overrideWorkerFixture(name, fixture) {
        this._pool.registerFixture(name, 'worker', fixture, name.startsWith('auto'), true);
    }
    defineParameter(name, description, defaultValue) {
        this._pool.registerWorkerParameter({
            name: name,
            description,
            defaultValue: defaultValue,
        });
        this._pool.registerFixture(name, 'worker', async ({}, runTest) => runTest(defaultValue), false, false);
    }
    build() {
        this._pool.validate();
        return new FixturesImpl(this._pool);
    }
}
exports.BuilderImpl = BuilderImpl;
exports.rootFixtures = new FixturesImpl(new fixtures_1.FixturePool(undefined));
//# sourceMappingURL=spec.js.map