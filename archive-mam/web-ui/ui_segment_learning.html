<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI 구간 학습 시스템 - Archive-MAM</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.0.0/dist/tf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0f0f0f;
            color: #ffffff;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            margin-bottom: 20px;
            color: #4CAF50;
            text-align: center;
        }
        
        .workflow-steps {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .step-card {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #4CAF50;
        }
        
        .step-card.active {
            border-left-color: #ff9800;
            background: #2a2a2a;
        }
        
        .step-card.completed {
            border-left-color: #4CAF50;
            opacity: 0.7;
        }
        
        .step-number {
            background: #4CAF50;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .step-card.active .step-number {
            background: #ff9800;
        }
        
        .video-section {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        video {
            width: 100%;
            max-width: 100%;
            height: auto;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: #4CAF50;
            color: white;
        }
        
        .btn-primary:hover {
            background: #45a049;
        }
        
        .btn-primary:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .btn-danger {
            background: #f44336;
            color: white;
        }
        
        .btn-danger:hover {
            background: #da190b;
        }
        
        .btn-warning {
            background: #ff9800;
            color: white;
        }
        
        .btn-warning:hover {
            background: #e68900;
        }
        
        .btn-info {
            background: #2196F3;
            color: white;
        }
        
        .btn-info:hover {
            background: #1976D2;
        }
        
        /* 특징 시각화 */
        .feature-visualization {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .frame-analysis {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .frame-preview {
            text-align: center;
        }
        
        .frame-canvas {
            max-width: 100%;
            border: 2px solid #333;
            border-radius: 5px;
        }
        
        .feature-stats {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
        }
        
        .feature-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .feature-bar {
            width: 100px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .feature-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }
        
        /* 학습 진행률 */
        .training-section {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .training-progress {
            margin-bottom: 20px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #2196F3);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .training-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        
        .metric-card {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .metric-label {
            font-size: 14px;
            color: #999;
            margin-top: 5px;
        }
        
        /* 데이터 목록 */
        .data-list {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .data-item {
            background: #2a2a2a;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .label-badge {
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .label-ui-start {
            background: #f44336;
            color: white;
        }
        
        .label-ui-end {
            background: #ff9800;
            color: white;
        }
        
        .label-game {
            background: #4CAF50;
            color: white;
        }
        
        /* 예측 결과 */
        .prediction-section {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .prediction-item {
            background: #2a2a2a;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        
        .confidence-bar {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .confidence-fill {
            height: 100%;
            border-radius: 3px;
        }
        
        .confidence-high {
            background: #4CAF50;
        }
        
        .confidence-medium {
            background: #ff9800;
        }
        
        .confidence-low {
            background: #f44336;
        }
        
        /* 입력 필드 */
        input[type="file"] {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 5px;
            color: white;
            margin-bottom: 20px;
            width: 100%;
        }
        
        .hidden {
            display: none;
        }
        
        /* 로딩 애니메이션 */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #333;
            border-radius: 50%;
            border-top-color: #4CAF50;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🧠 UI 구간 학습 시스템</h1>
        
        <!-- 워크플로우 단계 -->
        <div class="workflow-steps">
            <div class="step-card active" id="step1">
                <div class="step-number">1</div>
                <h3>데이터 준비</h3>
                <p>UI 구간 마킹 데이터를 불러와서 학습 데이터로 변환합니다.</p>
            </div>
            <div class="step-card" id="step2">
                <div class="step-number">2</div>
                <h3>특징 추출</h3>
                <p>UI 전환점의 시각적 특징을 분석하고 추출합니다.</p>
            </div>
            <div class="step-card" id="step3">
                <div class="step-number">3</div>
                <h3>모델 학습</h3>
                <p>TensorFlow.js로 UI 전환점 감지 모델을 학습합니다.</p>
            </div>
            <div class="step-card" id="step4">
                <div class="step-number">4</div>
                <h3>자동 예측</h3>
                <p>새로운 영상에서 UI 구간을 자동으로 감지합니다.</p>
            </div>
        </div>
        
        <!-- 1단계: 데이터 준비 -->
        <div id="dataPreparation">
            <h2>📂 1단계: 데이터 준비</h2>
            
            <div class="video-section">
                <input type="file" id="videoFile" accept="video/*">
                <input type="file" id="segmentDataFile" accept=".json">
                
                <video id="video" controls></video>
                
                <div class="controls">
                    <button class="btn-primary" onclick="loadSegmentData()">
                        📁 구간 데이터 불러오기
                    </button>
                    <button class="btn-warning" onclick="extractTrainingFrames()" disabled id="extractBtn">
                        🎯 학습 프레임 추출
                    </button>
                </div>
            </div>
            
            <div class="data-list">
                <h3>📋 학습 데이터 목록</h3>
                <div id="trainingDataList"></div>
            </div>
        </div>
        
        <!-- 2단계: 특징 추출 -->
        <div id="featureExtraction" class="hidden">
            <h2>🔍 2단계: 특징 추출</h2>
            
            <div class="feature-visualization">
                <div class="frame-analysis">
                    <div class="frame-preview">
                        <h4>현재 분석 프레임</h4>
                        <canvas class="frame-canvas" id="currentFrameCanvas" width="320" height="180"></canvas>
                    </div>
                    <div class="feature-stats">
                        <h4>추출된 특징</h4>
                        <div class="feature-item">
                            <span>색상 균일성:</span>
                            <div class="feature-bar">
                                <div class="feature-fill" id="colorUniformity"></div>
                            </div>
                        </div>
                        <div class="feature-item">
                            <span>텍스트 밀도:</span>
                            <div class="feature-bar">
                                <div class="feature-fill" id="textDensity"></div>
                            </div>
                        </div>
                        <div class="feature-item">
                            <span>엣지 밀도:</span>
                            <div class="feature-bar">
                                <div class="feature-fill" id="edgeDensity"></div>
                            </div>
                        </div>
                        <div class="feature-item">
                            <span>레이아웃 점수:</span>
                            <div class="feature-bar">
                                <div class="feature-fill" id="layoutScore"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="btn-primary" onclick="startFeatureExtraction()" id="featureBtn">
                        🚀 특징 추출 시작
                    </button>
                    <button class="btn-info" onclick="nextStep(3)">
                        ➡️ 다음 단계
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 3단계: 모델 학습 -->
        <div id="modelTraining" class="hidden">
            <h2>🧠 3단계: 모델 학습</h2>
            
            <div class="training-section">
                <div class="training-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="trainingProgress">0%</div>
                    </div>
                </div>
                
                <div class="training-metrics">
                    <div class="metric-card">
                        <div class="metric-value" id="currentEpoch">0</div>
                        <div class="metric-label">현재 에포크</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="trainingLoss">-</div>
                        <div class="metric-label">학습 손실</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="trainingAccuracy">-</div>
                        <div class="metric-label">학습 정확도</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="validationAccuracy">-</div>
                        <div class="metric-label">검증 정확도</div>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="btn-primary" onclick="startTraining()" id="trainBtn">
                        🚀 모델 학습 시작
                    </button>
                    <button class="btn-warning" onclick="stopTraining()" disabled id="stopBtn">
                        ⏹️ 학습 중단
                    </button>
                    <button class="btn-info" onclick="nextStep(4)" disabled id="nextToPredict">
                        ➡️ 예측 단계
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 4단계: 자동 예측 -->
        <div id="autoPrediction" class="hidden">
            <h2>🎯 4단계: 자동 예측</h2>
            
            <div class="video-section">
                <h3>새로운 영상 분석</h3>
                <input type="file" id="newVideoFile" accept="video/*">
                <video id="newVideo" controls></video>
                
                <div class="controls">
                    <button class="btn-primary" onclick="startAutoPrediction()" id="predictBtn">
                        🧠 자동 UI 구간 감지
                    </button>
                    <button class="btn-warning" onclick="exportPredictions()">
                        💾 결과 내보내기
                    </button>
                    <button class="btn-info" onclick="goToIncrementalLearning()">
                        🔄 점진적 학습으로 이동
                    </button>
                </div>
            </div>
            
            <div class="prediction-section">
                <h3>🎯 예측 결과</h3>
                <div id="predictionResults"></div>
                <div style="background: #2a2a2a; padding: 15px; border-radius: 5px; margin-top: 20px;">
                    <h4>💡 학습 개선 제안</h4>
                    <p>예측 결과가 만족스럽지 않다면, <strong>점진적 학습 시스템</strong>에서 이 영상을 추가 학습시킬 수 있습니다.</p>
                    <p>한 번 학습된 데이터는 자동으로 기억되어 중복 학습을 방지합니다.</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // 전역 변수
        let video = null;
        let newVideo = null;
        let trainingData = [];
        let segmentData = null;
        let model = null;
        let isTraining = false;
        let features = [];
        
        // 초기화
        document.addEventListener('DOMContentLoaded', () => {
            video = document.getElementById('video');
            newVideo = document.getElementById('newVideo');
            
            // 비디오 파일 선택
            document.getElementById('videoFile').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    video.src = URL.createObjectURL(file);
                }
            });
            
            document.getElementById('newVideoFile').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    newVideo.src = URL.createObjectURL(file);
                }
            });
        });
        
        // 구간 데이터 불러오기
        function loadSegmentData() {
            const fileInput = document.getElementById('segmentDataFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('먼저 구간 데이터 JSON 파일을 선택하세요.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    segmentData = JSON.parse(e.target.result);
                    document.getElementById('extractBtn').disabled = false;
                    alert(`${segmentData.uiSegments.length}개의 UI 구간을 불러왔습니다.`);
                } catch (err) {
                    alert('JSON 파일 읽기 오류: ' + err.message);
                }
            };
            reader.readAsText(file);
        }
        
        // 학습 프레임 추출
        async function extractTrainingFrames() {
            if (!video.src || !segmentData) {
                alert('비디오와 구간 데이터를 먼저 로드하세요.');
                return;
            }
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 224;
            canvas.height = 224;
            
            trainingData = [];
            
            // UI 구간별로 시작/종료 프레임 추출
            for (const segment of segmentData.uiSegments) {
                // UI 시작 프레임
                video.currentTime = segment.start;
                await waitForSeek();
                
                ctx.drawImage(video, 0, 0, 224, 224);
                const imageData = ctx.getImageData(0, 0, 224, 224);
                trainingData.push({
                    image: imageData,
                    label: 'ui_start',
                    time: segment.start
                });
                
                // UI 종료 프레임
                video.currentTime = segment.end;
                await waitForSeek();
                
                ctx.drawImage(video, 0, 0, 224, 224);
                const imageData2 = ctx.getImageData(0, 0, 224, 224);
                trainingData.push({
                    image: imageData2,
                    label: 'ui_end',
                    time: segment.end
                });
                
                // 게임 중간 프레임들 (각 구간 사이)
                const midTime = (segment.start + segment.end) / 2;
                video.currentTime = midTime;
                await waitForSeek();
                
                ctx.drawImage(video, 0, 0, 224, 224);
                const imageData3 = ctx.getImageData(0, 0, 224, 224);
                trainingData.push({
                    image: imageData3,
                    label: 'game',
                    time: midTime
                });
            }
            
            updateTrainingDataList();
            nextStep(2);
        }
        
        // 비디오 시크 대기
        function waitForSeek() {
            return new Promise(resolve => {
                const onSeeked = () => {
                    video.removeEventListener('seeked', onSeeked);
                    setTimeout(resolve, 100); // 프레임 안정화 대기
                };
                video.addEventListener('seeked', onSeeked);
            });
        }
        
        // 학습 데이터 목록 업데이트
        function updateTrainingDataList() {
            const list = document.getElementById('trainingDataList');
            list.innerHTML = '';
            
            trainingData.forEach((data, index) => {
                const item = document.createElement('div');
                item.className = 'data-item';
                
                const labelClass = data.label === 'ui_start' ? 'label-ui-start' : 
                                 data.label === 'ui_end' ? 'label-ui-end' : 'label-game';
                
                const labelText = data.label === 'ui_start' ? 'UI 시작' : 
                                data.label === 'ui_end' ? 'UI 종료' : '게임 중';
                
                item.innerHTML = `
                    <div>
                        <strong>프레임 #${index + 1}</strong><br>
                        시간: ${formatTime(data.time)}
                    </div>
                    <div class="label-badge ${labelClass}">${labelText}</div>
                `;
                list.appendChild(item);
            });
        }
        
        // 특징 추출 시작
        async function startFeatureExtraction() {
            if (trainingData.length === 0) {
                alert('먼저 학습 프레임을 추출하세요.');
                return;
            }
            
            const canvas = document.getElementById('currentFrameCanvas');
            const ctx = canvas.getContext('2d');
            
            features = [];
            
            for (let i = 0; i < trainingData.length; i++) {
                const data = trainingData[i];
                
                // 프레임 표시
                ctx.putImageData(data.image, 0, 0);
                
                // 특징 추출
                const feature = extractVisualFeatures(data.image);
                features.push({
                    ...feature,
                    label: data.label,
                    time: data.time
                });
                
                // 특징 시각화
                updateFeatureVisualization(feature);
                
                await new Promise(resolve => setTimeout(resolve, 500)); // 시각화를 위한 지연
            }
            
            alert('특징 추출이 완료되었습니다.');
        }
        
        // 시각적 특징 추출
        function extractVisualFeatures(imageData) {
            const data = imageData.data;
            let colorVariance = 0;
            let edgeCount = 0;
            let textLikePixels = 0;
            
            // 색상 분산 계산
            const pixels = [];
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const gray = (r + g + b) / 3;
                pixels.push(gray);
            }
            
            const mean = pixels.reduce((a, b) => a + b) / pixels.length;
            colorVariance = pixels.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / pixels.length;
            
            // 엣지 감지 (간단한 Sobel 필터)
            const width = imageData.width;
            const height = imageData.height;
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    const gx = -pixels[idx - width - 1] + pixels[idx - width + 1] - 2 * pixels[idx - 1] + 2 * pixels[idx + 1] - pixels[idx + width - 1] + pixels[idx + width + 1];
                    const gy = -pixels[idx - width - 1] - 2 * pixels[idx - width] - pixels[idx - width + 1] + pixels[idx + width - 1] + 2 * pixels[idx + width] + pixels[idx + width + 1];
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    
                    if (magnitude > 50) {
                        edgeCount++;
                    }
                }
            }
            
            // 텍스트 유사 픽셀 (고대비 영역)
            for (let i = 0; i < pixels.length - 1; i++) {
                if (Math.abs(pixels[i] - pixels[i + 1]) > 100) {
                    textLikePixels++;
                }
            }
            
            return {
                colorUniformity: Math.max(0, 100 - colorVariance / 10),
                textDensity: Math.min(100, textLikePixels / 100),
                edgeDensity: Math.min(100, edgeCount / 100),
                layoutScore: Math.min(100, (edgeCount + textLikePixels) / 200)
            };
        }
        
        // 특징 시각화 업데이트
        function updateFeatureVisualization(feature) {
            document.getElementById('colorUniformity').style.width = feature.colorUniformity + '%';
            document.getElementById('textDensity').style.width = feature.textDensity + '%';
            document.getElementById('edgeDensity').style.width = feature.edgeDensity + '%';
            document.getElementById('layoutScore').style.width = feature.layoutScore + '%';
        }
        
        // 모델 학습 시작
        async function startTraining() {
            if (features.length === 0) {
                alert('먼저 특징 추출을 완료하세요.');
                return;
            }
            
            isTraining = true;
            document.getElementById('trainBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            // TensorFlow.js 모델 생성
            model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [4], units: 16, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({ units: 8, activation: 'relu' }),
                    tf.layers.dense({ units: 3, activation: 'softmax' }) // ui_start, ui_end, game
                ]
            });
            
            model.compile({
                optimizer: 'adam',
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });
            
            // 학습 데이터 준비
            const xs = features.map(f => [f.colorUniformity, f.textDensity, f.edgeDensity, f.layoutScore]);
            const ys = features.map(f => {
                if (f.label === 'ui_start') return [1, 0, 0];
                if (f.label === 'ui_end') return [0, 1, 0];
                return [0, 0, 1]; // game
            });
            
            const xTensor = tf.tensor2d(xs);
            const yTensor = tf.tensor2d(ys);
            
            // 학습 진행
            try {
                await model.fit(xTensor, yTensor, {
                    epochs: 50,
                    validationSplit: 0.2,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            if (!isTraining) return;
                            
                            const progress = ((epoch + 1) / 50) * 100;
                            document.getElementById('trainingProgress').style.width = progress + '%';
                            document.getElementById('trainingProgress').textContent = Math.round(progress) + '%';
                            document.getElementById('currentEpoch').textContent = epoch + 1;
                            document.getElementById('trainingLoss').textContent = logs.loss.toFixed(4);
                            document.getElementById('trainingAccuracy').textContent = (logs.acc * 100).toFixed(1) + '%';
                            
                            if (logs.val_acc) {
                                document.getElementById('validationAccuracy').textContent = (logs.val_acc * 100).toFixed(1) + '%';
                            }
                        }
                    }
                });
                
                if (isTraining) {
                    alert('모델 학습이 완료되었습니다!');
                    document.getElementById('nextToPredict').disabled = false;
                }
            } catch (error) {
                alert('학습 중 오류 발생: ' + error.message);
            } finally {
                xTensor.dispose();
                yTensor.dispose();
                isTraining = false;
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
        }
        
        // 학습 중단
        function stopTraining() {
            isTraining = false;
            document.getElementById('stopBtn').disabled = true;
        }
        
        // 자동 예측 시작
        async function startAutoPrediction() {
            if (!model || !newVideo.src) {
                alert('학습된 모델과 새로운 비디오가 필요합니다.');
                return;
            }
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 224;
            canvas.height = 224;
            
            const predictions = [];
            const duration = newVideo.duration;
            const interval = 1; // 1초 간격
            
            for (let time = 0; time < duration; time += interval) {
                newVideo.currentTime = time;
                await waitForNewVideoSeek();
                
                ctx.drawImage(newVideo, 0, 0, 224, 224);
                const imageData = ctx.getImageData(0, 0, 224, 224);
                const feature = extractVisualFeatures(imageData);
                
                const input = tf.tensor2d([[feature.colorUniformity, feature.textDensity, feature.edgeDensity, feature.layoutScore]]);
                const prediction = model.predict(input);
                const probabilities = await prediction.data();
                
                predictions.push({
                    time: time,
                    uiStart: probabilities[0],
                    uiEnd: probabilities[1],
                    game: probabilities[2]
                });
                
                input.dispose();
                prediction.dispose();
            }
            
            displayPredictions(predictions);
        }
        
        // 새 비디오 시크 대기
        function waitForNewVideoSeek() {
            return new Promise(resolve => {
                const onSeeked = () => {
                    newVideo.removeEventListener('seeked', onSeeked);
                    setTimeout(resolve, 100);
                };
                newVideo.addEventListener('seeked', onSeeked);
            });
        }
        
        // 예측 결과 표시
        function displayPredictions(predictions) {
            const resultsDiv = document.getElementById('predictionResults');
            resultsDiv.innerHTML = '';
            
            predictions.forEach((pred, index) => {
                const maxProb = Math.max(pred.uiStart, pred.uiEnd, pred.game);
                const predictedLabel = pred.uiStart === maxProb ? 'UI 시작' : 
                                     pred.uiEnd === maxProb ? 'UI 종료' : '게임 중';
                
                const item = document.createElement('div');
                item.className = 'prediction-item';
                
                const confidenceClass = maxProb > 0.8 ? 'confidence-high' : 
                                       maxProb > 0.5 ? 'confidence-medium' : 'confidence-low';
                
                item.innerHTML = `
                    <div>
                        <strong>${formatTime(pred.time)}</strong> - ${predictedLabel}
                        <div class="confidence-bar">
                            <div class="confidence-fill ${confidenceClass}" style="width: ${maxProb * 100}%"></div>
                        </div>
                        <small>신뢰도: ${(maxProb * 100).toFixed(1)}%</small>
                    </div>
                `;
                resultsDiv.appendChild(item);
            });
        }
        
        // 단계 전환
        function nextStep(step) {
            // 모든 단계 숨기기
            document.getElementById('dataPreparation').classList.add('hidden');
            document.getElementById('featureExtraction').classList.add('hidden');
            document.getElementById('modelTraining').classList.add('hidden');
            document.getElementById('autoPrediction').classList.add('hidden');
            
            // 단계 카드 업데이트
            for (let i = 1; i <= 4; i++) {
                const card = document.getElementById(`step${i}`);
                card.classList.remove('active', 'completed');
                if (i < step) card.classList.add('completed');
                if (i === step) card.classList.add('active');
            }
            
            // 해당 단계 표시
            switch (step) {
                case 1:
                    document.getElementById('dataPreparation').classList.remove('hidden');
                    break;
                case 2:
                    document.getElementById('featureExtraction').classList.remove('hidden');
                    break;
                case 3:
                    document.getElementById('modelTraining').classList.remove('hidden');
                    break;
                case 4:
                    document.getElementById('autoPrediction').classList.remove('hidden');
                    break;
            }
        }
        
        // 예측 결과 내보내기
        function exportPredictions() {
            const results = Array.from(document.getElementById('predictionResults').children).map(item => {
                const text = item.textContent;
                return {
                    time: text.split(' ')[0],
                    prediction: text.split(' - ')[1].split('\n')[0],
                    confidence: text.match(/신뢰도: ([\d.]+)%/)[1]
                };
            });
            
            const data = {
                predictions: results,
                exportDate: new Date().toISOString()
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `ui_predictions_${Date.now()}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
        }
        
        // 점진적 학습으로 이동
        function goToIncrementalLearning() {
            window.open('incremental_learning_system.html', '_blank');
        }
        
        // 시간 포맷팅
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
    </script>
</body>
</html>