<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI êµ¬ê°„ í•™ìŠµ ì‹œìŠ¤í…œ - Archive-MAM</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.0.0/dist/tf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0f0f0f;
            color: #ffffff;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            margin-bottom: 20px;
            color: #4CAF50;
            text-align: center;
        }
        
        .workflow-steps {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .step-card {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #4CAF50;
        }
        
        .step-card.active {
            border-left-color: #ff9800;
            background: #2a2a2a;
        }
        
        .step-card.completed {
            border-left-color: #4CAF50;
            opacity: 0.7;
        }
        
        .step-number {
            background: #4CAF50;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .step-card.active .step-number {
            background: #ff9800;
        }
        
        .video-section {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        video {
            width: 100%;
            max-width: 100%;
            height: auto;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: #4CAF50;
            color: white;
        }
        
        .btn-primary:hover {
            background: #45a049;
        }
        
        .btn-primary:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .btn-danger {
            background: #f44336;
            color: white;
        }
        
        .btn-danger:hover {
            background: #da190b;
        }
        
        .btn-warning {
            background: #ff9800;
            color: white;
        }
        
        .btn-warning:hover {
            background: #e68900;
        }
        
        .btn-info {
            background: #2196F3;
            color: white;
        }
        
        .btn-info:hover {
            background: #1976D2;
        }
        
        /* íŠ¹ì§• ì‹œê°í™” */
        .feature-visualization {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .frame-analysis {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .frame-preview {
            text-align: center;
        }
        
        .frame-canvas {
            max-width: 100%;
            border: 2px solid #333;
            border-radius: 5px;
        }
        
        .feature-stats {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
        }
        
        .feature-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .feature-bar {
            width: 100px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .feature-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }
        
        /* í•™ìŠµ ì§„í–‰ë¥  */
        .training-section {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .training-progress {
            margin-bottom: 20px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #2196F3);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .training-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        
        .metric-card {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .metric-label {
            font-size: 14px;
            color: #999;
            margin-top: 5px;
        }
        
        /* ë°ì´í„° ëª©ë¡ */
        .data-list {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .data-item {
            background: #2a2a2a;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .label-badge {
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .label-ui-start {
            background: #f44336;
            color: white;
        }
        
        .label-ui-end {
            background: #ff9800;
            color: white;
        }
        
        .label-game {
            background: #4CAF50;
            color: white;
        }
        
        /* ì˜ˆì¸¡ ê²°ê³¼ */
        .prediction-section {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .prediction-item {
            background: #2a2a2a;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        
        .confidence-bar {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .confidence-fill {
            height: 100%;
            border-radius: 3px;
        }
        
        .confidence-high {
            background: #4CAF50;
        }
        
        .confidence-medium {
            background: #ff9800;
        }
        
        .confidence-low {
            background: #f44336;
        }
        
        /* ì…ë ¥ í•„ë“œ */
        input[type="file"] {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 5px;
            color: white;
            margin-bottom: 20px;
            width: 100%;
        }
        
        .hidden {
            display: none;
        }
        
        /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #333;
            border-radius: 50%;
            border-top-color: #4CAF50;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§  UI êµ¬ê°„ í•™ìŠµ ì‹œìŠ¤í…œ</h1>
        
        <!-- ì›Œí¬í”Œë¡œìš° ë‹¨ê³„ -->
        <div class="workflow-steps">
            <div class="step-card active" id="step1">
                <div class="step-number">1</div>
                <h3>ë°ì´í„° ì¤€ë¹„</h3>
                <p>UI êµ¬ê°„ ë§ˆí‚¹ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™€ì„œ í•™ìŠµ ë°ì´í„°ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.</p>
            </div>
            <div class="step-card" id="step2">
                <div class="step-number">2</div>
                <h3>íŠ¹ì§• ì¶”ì¶œ</h3>
                <p>UI ì „í™˜ì ì˜ ì‹œê°ì  íŠ¹ì§•ì„ ë¶„ì„í•˜ê³  ì¶”ì¶œí•©ë‹ˆë‹¤.</p>
            </div>
            <div class="step-card" id="step3">
                <div class="step-number">3</div>
                <h3>ëª¨ë¸ í•™ìŠµ</h3>
                <p>TensorFlow.jsë¡œ UI ì „í™˜ì  ê°ì§€ ëª¨ë¸ì„ í•™ìŠµí•©ë‹ˆë‹¤.</p>
            </div>
            <div class="step-card" id="step4">
                <div class="step-number">4</div>
                <h3>ìë™ ì˜ˆì¸¡</h3>
                <p>ìƒˆë¡œìš´ ì˜ìƒì—ì„œ UI êµ¬ê°„ì„ ìë™ìœ¼ë¡œ ê°ì§€í•©ë‹ˆë‹¤.</p>
            </div>
        </div>
        
        <!-- 1ë‹¨ê³„: ë°ì´í„° ì¤€ë¹„ -->
        <div id="dataPreparation">
            <h2>ğŸ“‚ 1ë‹¨ê³„: ë°ì´í„° ì¤€ë¹„</h2>
            
            <div class="video-section">
                <input type="file" id="videoFile" accept="video/*">
                <input type="file" id="segmentDataFile" accept=".json">
                
                <video id="video" controls></video>
                
                <div class="controls">
                    <button class="btn-primary" onclick="loadSegmentData()">
                        ğŸ“ êµ¬ê°„ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
                    </button>
                    <button class="btn-warning" onclick="extractTrainingFrames()" disabled id="extractBtn">
                        ğŸ¯ í•™ìŠµ í”„ë ˆì„ ì¶”ì¶œ
                    </button>
                </div>
            </div>
            
            <div class="data-list">
                <h3>ğŸ“‹ í•™ìŠµ ë°ì´í„° ëª©ë¡</h3>
                <div id="trainingDataList"></div>
            </div>
        </div>
        
        <!-- 2ë‹¨ê³„: íŠ¹ì§• ì¶”ì¶œ -->
        <div id="featureExtraction" class="hidden">
            <h2>ğŸ” 2ë‹¨ê³„: íŠ¹ì§• ì¶”ì¶œ</h2>
            
            <div class="feature-visualization">
                <div class="frame-analysis">
                    <div class="frame-preview">
                        <h4>í˜„ì¬ ë¶„ì„ í”„ë ˆì„</h4>
                        <canvas class="frame-canvas" id="currentFrameCanvas" width="320" height="180"></canvas>
                    </div>
                    <div class="feature-stats">
                        <h4>ì¶”ì¶œëœ íŠ¹ì§•</h4>
                        <div class="feature-item">
                            <span>ìƒ‰ìƒ ê· ì¼ì„±:</span>
                            <div class="feature-bar">
                                <div class="feature-fill" id="colorUniformity"></div>
                            </div>
                        </div>
                        <div class="feature-item">
                            <span>í…ìŠ¤íŠ¸ ë°€ë„:</span>
                            <div class="feature-bar">
                                <div class="feature-fill" id="textDensity"></div>
                            </div>
                        </div>
                        <div class="feature-item">
                            <span>ì—£ì§€ ë°€ë„:</span>
                            <div class="feature-bar">
                                <div class="feature-fill" id="edgeDensity"></div>
                            </div>
                        </div>
                        <div class="feature-item">
                            <span>ë ˆì´ì•„ì›ƒ ì ìˆ˜:</span>
                            <div class="feature-bar">
                                <div class="feature-fill" id="layoutScore"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="btn-primary" onclick="startFeatureExtraction()" id="featureBtn">
                        ğŸš€ íŠ¹ì§• ì¶”ì¶œ ì‹œì‘
                    </button>
                    <button class="btn-info" onclick="nextStep(3)">
                        â¡ï¸ ë‹¤ìŒ ë‹¨ê³„
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 3ë‹¨ê³„: ëª¨ë¸ í•™ìŠµ -->
        <div id="modelTraining" class="hidden">
            <h2>ğŸ§  3ë‹¨ê³„: ëª¨ë¸ í•™ìŠµ</h2>
            
            <div class="training-section">
                <div class="training-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="trainingProgress">0%</div>
                    </div>
                </div>
                
                <div class="training-metrics">
                    <div class="metric-card">
                        <div class="metric-value" id="currentEpoch">0</div>
                        <div class="metric-label">í˜„ì¬ ì—í¬í¬</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="trainingLoss">-</div>
                        <div class="metric-label">í•™ìŠµ ì†ì‹¤</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="trainingAccuracy">-</div>
                        <div class="metric-label">í•™ìŠµ ì •í™•ë„</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="validationAccuracy">-</div>
                        <div class="metric-label">ê²€ì¦ ì •í™•ë„</div>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="btn-primary" onclick="startTraining()" id="trainBtn">
                        ğŸš€ ëª¨ë¸ í•™ìŠµ ì‹œì‘
                    </button>
                    <button class="btn-warning" onclick="stopTraining()" disabled id="stopBtn">
                        â¹ï¸ í•™ìŠµ ì¤‘ë‹¨
                    </button>
                    <button class="btn-info" onclick="nextStep(4)" disabled id="nextToPredict">
                        â¡ï¸ ì˜ˆì¸¡ ë‹¨ê³„
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 4ë‹¨ê³„: ìë™ ì˜ˆì¸¡ -->
        <div id="autoPrediction" class="hidden">
            <h2>ğŸ¯ 4ë‹¨ê³„: ìë™ ì˜ˆì¸¡</h2>
            
            <div class="video-section">
                <h3>ìƒˆë¡œìš´ ì˜ìƒ ë¶„ì„</h3>
                <input type="file" id="newVideoFile" accept="video/*">
                <video id="newVideo" controls></video>
                
                <div class="controls">
                    <button class="btn-primary" onclick="startAutoPrediction()" id="predictBtn">
                        ğŸ§  ìë™ UI êµ¬ê°„ ê°ì§€
                    </button>
                    <button class="btn-warning" onclick="exportPredictions()">
                        ğŸ’¾ ê²°ê³¼ ë‚´ë³´ë‚´ê¸°
                    </button>
                    <button class="btn-info" onclick="goToIncrementalLearning()">
                        ğŸ”„ ì ì§„ì  í•™ìŠµìœ¼ë¡œ ì´ë™
                    </button>
                </div>
            </div>
            
            <div class="prediction-section">
                <h3>ğŸ¯ ì˜ˆì¸¡ ê²°ê³¼</h3>
                <div id="predictionResults"></div>
                <div style="background: #2a2a2a; padding: 15px; border-radius: 5px; margin-top: 20px;">
                    <h4>ğŸ’¡ í•™ìŠµ ê°œì„  ì œì•ˆ</h4>
                    <p>ì˜ˆì¸¡ ê²°ê³¼ê°€ ë§Œì¡±ìŠ¤ëŸ½ì§€ ì•Šë‹¤ë©´, <strong>ì ì§„ì  í•™ìŠµ ì‹œìŠ¤í…œ</strong>ì—ì„œ ì´ ì˜ìƒì„ ì¶”ê°€ í•™ìŠµì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
                    <p>í•œ ë²ˆ í•™ìŠµëœ ë°ì´í„°ëŠ” ìë™ìœ¼ë¡œ ê¸°ì–µë˜ì–´ ì¤‘ë³µ í•™ìŠµì„ ë°©ì§€í•©ë‹ˆë‹¤.</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // ì „ì—­ ë³€ìˆ˜
        let video = null;
        let newVideo = null;
        let trainingData = [];
        let segmentData = null;
        let model = null;
        let isTraining = false;
        let features = [];
        
        // ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            video = document.getElementById('video');
            newVideo = document.getElementById('newVideo');
            
            // ë¹„ë””ì˜¤ íŒŒì¼ ì„ íƒ
            document.getElementById('videoFile').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    video.src = URL.createObjectURL(file);
                }
            });
            
            document.getElementById('newVideoFile').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    newVideo.src = URL.createObjectURL(file);
                }
            });
        });
        
        // êµ¬ê°„ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
        function loadSegmentData() {
            const fileInput = document.getElementById('segmentDataFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('ë¨¼ì € êµ¬ê°„ ë°ì´í„° JSON íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    segmentData = JSON.parse(e.target.result);
                    document.getElementById('extractBtn').disabled = false;
                    alert(`${segmentData.uiSegments.length}ê°œì˜ UI êµ¬ê°„ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);
                } catch (err) {
                    alert('JSON íŒŒì¼ ì½ê¸° ì˜¤ë¥˜: ' + err.message);
                }
            };
            reader.readAsText(file);
        }
        
        // í•™ìŠµ í”„ë ˆì„ ì¶”ì¶œ
        async function extractTrainingFrames() {
            if (!video.src || !segmentData) {
                alert('ë¹„ë””ì˜¤ì™€ êµ¬ê°„ ë°ì´í„°ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                return;
            }
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 224;
            canvas.height = 224;
            
            trainingData = [];
            
            // UI êµ¬ê°„ë³„ë¡œ ì‹œì‘/ì¢…ë£Œ í”„ë ˆì„ ì¶”ì¶œ
            for (const segment of segmentData.uiSegments) {
                // UI ì‹œì‘ í”„ë ˆì„
                video.currentTime = segment.start;
                await waitForSeek();
                
                ctx.drawImage(video, 0, 0, 224, 224);
                const imageData = ctx.getImageData(0, 0, 224, 224);
                trainingData.push({
                    image: imageData,
                    label: 'ui_start',
                    time: segment.start
                });
                
                // UI ì¢…ë£Œ í”„ë ˆì„
                video.currentTime = segment.end;
                await waitForSeek();
                
                ctx.drawImage(video, 0, 0, 224, 224);
                const imageData2 = ctx.getImageData(0, 0, 224, 224);
                trainingData.push({
                    image: imageData2,
                    label: 'ui_end',
                    time: segment.end
                });
                
                // ê²Œì„ ì¤‘ê°„ í”„ë ˆì„ë“¤ (ê° êµ¬ê°„ ì‚¬ì´)
                const midTime = (segment.start + segment.end) / 2;
                video.currentTime = midTime;
                await waitForSeek();
                
                ctx.drawImage(video, 0, 0, 224, 224);
                const imageData3 = ctx.getImageData(0, 0, 224, 224);
                trainingData.push({
                    image: imageData3,
                    label: 'game',
                    time: midTime
                });
            }
            
            updateTrainingDataList();
            nextStep(2);
        }
        
        // ë¹„ë””ì˜¤ ì‹œí¬ ëŒ€ê¸°
        function waitForSeek() {
            return new Promise(resolve => {
                const onSeeked = () => {
                    video.removeEventListener('seeked', onSeeked);
                    setTimeout(resolve, 100); // í”„ë ˆì„ ì•ˆì •í™” ëŒ€ê¸°
                };
                video.addEventListener('seeked', onSeeked);
            });
        }
        
        // í•™ìŠµ ë°ì´í„° ëª©ë¡ ì—…ë°ì´íŠ¸
        function updateTrainingDataList() {
            const list = document.getElementById('trainingDataList');
            list.innerHTML = '';
            
            trainingData.forEach((data, index) => {
                const item = document.createElement('div');
                item.className = 'data-item';
                
                const labelClass = data.label === 'ui_start' ? 'label-ui-start' : 
                                 data.label === 'ui_end' ? 'label-ui-end' : 'label-game';
                
                const labelText = data.label === 'ui_start' ? 'UI ì‹œì‘' : 
                                data.label === 'ui_end' ? 'UI ì¢…ë£Œ' : 'ê²Œì„ ì¤‘';
                
                item.innerHTML = `
                    <div>
                        <strong>í”„ë ˆì„ #${index + 1}</strong><br>
                        ì‹œê°„: ${formatTime(data.time)}
                    </div>
                    <div class="label-badge ${labelClass}">${labelText}</div>
                `;
                list.appendChild(item);
            });
        }
        
        // íŠ¹ì§• ì¶”ì¶œ ì‹œì‘
        async function startFeatureExtraction() {
            if (trainingData.length === 0) {
                alert('ë¨¼ì € í•™ìŠµ í”„ë ˆì„ì„ ì¶”ì¶œí•˜ì„¸ìš”.');
                return;
            }
            
            const canvas = document.getElementById('currentFrameCanvas');
            const ctx = canvas.getContext('2d');
            
            features = [];
            
            for (let i = 0; i < trainingData.length; i++) {
                const data = trainingData[i];
                
                // í”„ë ˆì„ í‘œì‹œ
                ctx.putImageData(data.image, 0, 0);
                
                // íŠ¹ì§• ì¶”ì¶œ
                const feature = extractVisualFeatures(data.image);
                features.push({
                    ...feature,
                    label: data.label,
                    time: data.time
                });
                
                // íŠ¹ì§• ì‹œê°í™”
                updateFeatureVisualization(feature);
                
                await new Promise(resolve => setTimeout(resolve, 500)); // ì‹œê°í™”ë¥¼ ìœ„í•œ ì§€ì—°
            }
            
            alert('íŠ¹ì§• ì¶”ì¶œì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
        }
        
        // ì‹œê°ì  íŠ¹ì§• ì¶”ì¶œ
        function extractVisualFeatures(imageData) {
            const data = imageData.data;
            let colorVariance = 0;
            let edgeCount = 0;
            let textLikePixels = 0;
            
            // ìƒ‰ìƒ ë¶„ì‚° ê³„ì‚°
            const pixels = [];
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const gray = (r + g + b) / 3;
                pixels.push(gray);
            }
            
            const mean = pixels.reduce((a, b) => a + b) / pixels.length;
            colorVariance = pixels.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / pixels.length;
            
            // ì—£ì§€ ê°ì§€ (ê°„ë‹¨í•œ Sobel í•„í„°)
            const width = imageData.width;
            const height = imageData.height;
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    const gx = -pixels[idx - width - 1] + pixels[idx - width + 1] - 2 * pixels[idx - 1] + 2 * pixels[idx + 1] - pixels[idx + width - 1] + pixels[idx + width + 1];
                    const gy = -pixels[idx - width - 1] - 2 * pixels[idx - width] - pixels[idx - width + 1] + pixels[idx + width - 1] + 2 * pixels[idx + width] + pixels[idx + width + 1];
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    
                    if (magnitude > 50) {
                        edgeCount++;
                    }
                }
            }
            
            // í…ìŠ¤íŠ¸ ìœ ì‚¬ í”½ì…€ (ê³ ëŒ€ë¹„ ì˜ì—­)
            for (let i = 0; i < pixels.length - 1; i++) {
                if (Math.abs(pixels[i] - pixels[i + 1]) > 100) {
                    textLikePixels++;
                }
            }
            
            return {
                colorUniformity: Math.max(0, 100 - colorVariance / 10),
                textDensity: Math.min(100, textLikePixels / 100),
                edgeDensity: Math.min(100, edgeCount / 100),
                layoutScore: Math.min(100, (edgeCount + textLikePixels) / 200)
            };
        }
        
        // íŠ¹ì§• ì‹œê°í™” ì—…ë°ì´íŠ¸
        function updateFeatureVisualization(feature) {
            document.getElementById('colorUniformity').style.width = feature.colorUniformity + '%';
            document.getElementById('textDensity').style.width = feature.textDensity + '%';
            document.getElementById('edgeDensity').style.width = feature.edgeDensity + '%';
            document.getElementById('layoutScore').style.width = feature.layoutScore + '%';
        }
        
        // ëª¨ë¸ í•™ìŠµ ì‹œì‘
        async function startTraining() {
            if (features.length === 0) {
                alert('ë¨¼ì € íŠ¹ì§• ì¶”ì¶œì„ ì™„ë£Œí•˜ì„¸ìš”.');
                return;
            }
            
            isTraining = true;
            document.getElementById('trainBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            // TensorFlow.js ëª¨ë¸ ìƒì„±
            model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [4], units: 16, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({ units: 8, activation: 'relu' }),
                    tf.layers.dense({ units: 3, activation: 'softmax' }) // ui_start, ui_end, game
                ]
            });
            
            model.compile({
                optimizer: 'adam',
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });
            
            // í•™ìŠµ ë°ì´í„° ì¤€ë¹„
            const xs = features.map(f => [f.colorUniformity, f.textDensity, f.edgeDensity, f.layoutScore]);
            const ys = features.map(f => {
                if (f.label === 'ui_start') return [1, 0, 0];
                if (f.label === 'ui_end') return [0, 1, 0];
                return [0, 0, 1]; // game
            });
            
            const xTensor = tf.tensor2d(xs);
            const yTensor = tf.tensor2d(ys);
            
            // í•™ìŠµ ì§„í–‰
            try {
                await model.fit(xTensor, yTensor, {
                    epochs: 50,
                    validationSplit: 0.2,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            if (!isTraining) return;
                            
                            const progress = ((epoch + 1) / 50) * 100;
                            document.getElementById('trainingProgress').style.width = progress + '%';
                            document.getElementById('trainingProgress').textContent = Math.round(progress) + '%';
                            document.getElementById('currentEpoch').textContent = epoch + 1;
                            document.getElementById('trainingLoss').textContent = logs.loss.toFixed(4);
                            document.getElementById('trainingAccuracy').textContent = (logs.acc * 100).toFixed(1) + '%';
                            
                            if (logs.val_acc) {
                                document.getElementById('validationAccuracy').textContent = (logs.val_acc * 100).toFixed(1) + '%';
                            }
                        }
                    }
                });
                
                if (isTraining) {
                    alert('ëª¨ë¸ í•™ìŠµì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!');
                    document.getElementById('nextToPredict').disabled = false;
                }
            } catch (error) {
                alert('í•™ìŠµ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
            } finally {
                xTensor.dispose();
                yTensor.dispose();
                isTraining = false;
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
        }
        
        // í•™ìŠµ ì¤‘ë‹¨
        function stopTraining() {
            isTraining = false;
            document.getElementById('stopBtn').disabled = true;
        }
        
        // ìë™ ì˜ˆì¸¡ ì‹œì‘
        async function startAutoPrediction() {
            if (!model || !newVideo.src) {
                alert('í•™ìŠµëœ ëª¨ë¸ê³¼ ìƒˆë¡œìš´ ë¹„ë””ì˜¤ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
                return;
            }
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 224;
            canvas.height = 224;
            
            const predictions = [];
            const duration = newVideo.duration;
            const interval = 1; // 1ì´ˆ ê°„ê²©
            
            for (let time = 0; time < duration; time += interval) {
                newVideo.currentTime = time;
                await waitForNewVideoSeek();
                
                ctx.drawImage(newVideo, 0, 0, 224, 224);
                const imageData = ctx.getImageData(0, 0, 224, 224);
                const feature = extractVisualFeatures(imageData);
                
                const input = tf.tensor2d([[feature.colorUniformity, feature.textDensity, feature.edgeDensity, feature.layoutScore]]);
                const prediction = model.predict(input);
                const probabilities = await prediction.data();
                
                predictions.push({
                    time: time,
                    uiStart: probabilities[0],
                    uiEnd: probabilities[1],
                    game: probabilities[2]
                });
                
                input.dispose();
                prediction.dispose();
            }
            
            displayPredictions(predictions);
        }
        
        // ìƒˆ ë¹„ë””ì˜¤ ì‹œí¬ ëŒ€ê¸°
        function waitForNewVideoSeek() {
            return new Promise(resolve => {
                const onSeeked = () => {
                    newVideo.removeEventListener('seeked', onSeeked);
                    setTimeout(resolve, 100);
                };
                newVideo.addEventListener('seeked', onSeeked);
            });
        }
        
        // ì˜ˆì¸¡ ê²°ê³¼ í‘œì‹œ
        function displayPredictions(predictions) {
            const resultsDiv = document.getElementById('predictionResults');
            resultsDiv.innerHTML = '';
            
            predictions.forEach((pred, index) => {
                const maxProb = Math.max(pred.uiStart, pred.uiEnd, pred.game);
                const predictedLabel = pred.uiStart === maxProb ? 'UI ì‹œì‘' : 
                                     pred.uiEnd === maxProb ? 'UI ì¢…ë£Œ' : 'ê²Œì„ ì¤‘';
                
                const item = document.createElement('div');
                item.className = 'prediction-item';
                
                const confidenceClass = maxProb > 0.8 ? 'confidence-high' : 
                                       maxProb > 0.5 ? 'confidence-medium' : 'confidence-low';
                
                item.innerHTML = `
                    <div>
                        <strong>${formatTime(pred.time)}</strong> - ${predictedLabel}
                        <div class="confidence-bar">
                            <div class="confidence-fill ${confidenceClass}" style="width: ${maxProb * 100}%"></div>
                        </div>
                        <small>ì‹ ë¢°ë„: ${(maxProb * 100).toFixed(1)}%</small>
                    </div>
                `;
                resultsDiv.appendChild(item);
            });
        }
        
        // ë‹¨ê³„ ì „í™˜
        function nextStep(step) {
            // ëª¨ë“  ë‹¨ê³„ ìˆ¨ê¸°ê¸°
            document.getElementById('dataPreparation').classList.add('hidden');
            document.getElementById('featureExtraction').classList.add('hidden');
            document.getElementById('modelTraining').classList.add('hidden');
            document.getElementById('autoPrediction').classList.add('hidden');
            
            // ë‹¨ê³„ ì¹´ë“œ ì—…ë°ì´íŠ¸
            for (let i = 1; i <= 4; i++) {
                const card = document.getElementById(`step${i}`);
                card.classList.remove('active', 'completed');
                if (i < step) card.classList.add('completed');
                if (i === step) card.classList.add('active');
            }
            
            // í•´ë‹¹ ë‹¨ê³„ í‘œì‹œ
            switch (step) {
                case 1:
                    document.getElementById('dataPreparation').classList.remove('hidden');
                    break;
                case 2:
                    document.getElementById('featureExtraction').classList.remove('hidden');
                    break;
                case 3:
                    document.getElementById('modelTraining').classList.remove('hidden');
                    break;
                case 4:
                    document.getElementById('autoPrediction').classList.remove('hidden');
                    break;
            }
        }
        
        // ì˜ˆì¸¡ ê²°ê³¼ ë‚´ë³´ë‚´ê¸°
        function exportPredictions() {
            const results = Array.from(document.getElementById('predictionResults').children).map(item => {
                const text = item.textContent;
                return {
                    time: text.split(' ')[0],
                    prediction: text.split(' - ')[1].split('\n')[0],
                    confidence: text.match(/ì‹ ë¢°ë„: ([\d.]+)%/)[1]
                };
            });
            
            const data = {
                predictions: results,
                exportDate: new Date().toISOString()
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `ui_predictions_${Date.now()}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
        }
        
        // ì ì§„ì  í•™ìŠµìœ¼ë¡œ ì´ë™
        function goToIncrementalLearning() {
            window.open('incremental_learning_system.html', '_blank');
        }
        
        // ì‹œê°„ í¬ë§·íŒ…
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
    </script>
</body>
</html>