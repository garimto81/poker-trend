<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì ì§„ì  í•™ìŠµ ì‹œìŠ¤í…œ - Archive-MAM</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.0.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0f0f0f;
            color: #ffffff;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            margin-bottom: 20px;
            color: #4CAF50;
            text-align: center;
        }
        
        /* ëŒ€ì‹œë³´ë“œ */
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .dashboard-card {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #4CAF50;
        }
        
        .dashboard-value {
            font-size: 32px;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 5px;
        }
        
        .dashboard-label {
            color: #999;
            font-size: 14px;
        }
        
        .dashboard-change {
            font-size: 12px;
            margin-top: 5px;
        }
        
        .change-positive {
            color: #4CAF50;
        }
        
        .change-negative {
            color: #f44336;
        }
        
        /* í•™ìŠµ íˆìŠ¤í† ë¦¬ */
        .learning-history {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .history-item {
            background: #2a2a2a;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .history-info {
            flex: 1;
        }
        
        .history-date {
            color: #999;
            font-size: 12px;
        }
        
        .history-stats {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .stat-badge {
            background: #4CAF50;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            color: white;
        }
        
        /* ë°ì´í„° ì¤‘ë³µ ì²´í¬ */
        .data-validation {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .validation-item {
            background: #2a2a2a;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .status-new {
            color: #4CAF50;
        }
        
        .status-duplicate {
            color: #ff9800;
        }
        
        .status-similar {
            color: #2196F3;
        }
        
        /* í•™ìŠµ ì„¹ì…˜ */
        .learning-section {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .learning-mode {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .mode-card {
            flex: 1;
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .mode-card.active {
            border-color: #4CAF50;
            background: #1e3a1e;
        }
        
        .mode-card:hover {
            background: #333;
        }
        
        /* ì§„í–‰ë¥  ë°” */
        .progress-container {
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #2196F3);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            margin: 5px;
        }
        
        .btn-primary {
            background: #4CAF50;
            color: white;
        }
        
        .btn-primary:hover {
            background: #45a049;
        }
        
        .btn-primary:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .btn-warning {
            background: #ff9800;
            color: white;
        }
        
        .btn-danger {
            background: #f44336;
            color: white;
        }
        
        .btn-info {
            background: #2196F3;
            color: white;
        }
        
        /* ì…ë ¥ í•„ë“œ */
        input[type="file"] {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 5px;
            color: white;
            margin-bottom: 20px;
            width: 100%;
        }
        
        /* ëª¨ë¸ ì„±ëŠ¥ ì°¨íŠ¸ */
        .performance-chart {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            position: relative;
            height: 200px;
            background: #2a2a2a;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .chart-line {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #4CAF50;
            transition: all 0.3s;
        }
        
        /* ë°ì´í„° í’ˆì§ˆ ì§€í‘œ */
        .quality-metrics {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .quality-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .quality-bar {
            width: 150px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .quality-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }
        
        .quality-excellent {
            background: #4CAF50;
        }
        
        .quality-good {
            background: #8BC34A;
        }
        
        .quality-fair {
            background: #ff9800;
        }
        
        .quality-poor {
            background: #f44336;
        }
        
        /* ì•Œë¦¼ ì‹œìŠ¤í…œ */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.success {
            background: #4CAF50;
        }
        
        .notification.warning {
            background: #ff9800;
        }
        
        .notification.error {
            background: #f44336;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”„ ì ì§„ì  í•™ìŠµ ì‹œìŠ¤í…œ</h1>
        
        <!-- ëŒ€ì‹œë³´ë“œ -->
        <div class="dashboard">
            <div class="dashboard-card">
                <div class="dashboard-value" id="totalSamples">0</div>
                <div class="dashboard-label">ì´ í•™ìŠµ ìƒ˜í”Œ</div>
                <div class="dashboard-change" id="samplesChange">+0 (ì´ë²ˆ ì„¸ì…˜)</div>
            </div>
            <div class="dashboard-card">
                <div class="dashboard-value" id="modelAccuracy">0%</div>
                <div class="dashboard-label">í˜„ì¬ ëª¨ë¸ ì •í™•ë„</div>
                <div class="dashboard-change" id="accuracyChange">+0% (ê°œì„ )</div>
            </div>
            <div class="dashboard-card">
                <div class="dashboard-value" id="uniqueVideos">0</div>
                <div class="dashboard-label">í•™ìŠµëœ ì˜ìƒ ìˆ˜</div>
                <div class="dashboard-change" id="videosChange">+0 (ìƒˆ ì˜ìƒ)</div>
            </div>
            <div class="dashboard-card">
                <div class="dashboard-value" id="learningVersion">v1.0</div>
                <div class="dashboard-label">ëª¨ë¸ ë²„ì „</div>
                <div class="dashboard-change" id="versionChange">ìµœì‹ </div>
            </div>
        </div>
        
        <!-- ìƒˆ ë°ì´í„° ì¶”ê°€ -->
        <div class="learning-section">
            <h2>ğŸ“¥ ìƒˆ ë°ì´í„° ì¶”ê°€</h2>
            
            <input type="file" id="newSegmentData" accept=".json">
            <input type="file" id="newVideoFile" accept="video/*">
            
            <div class="learning-mode">
                <div class="mode-card active" onclick="selectMode('incremental')">
                    <h4>ğŸ”„ ì ì§„ì  í•™ìŠµ</h4>
                    <p>ê¸°ì¡´ ëª¨ë¸ì— ìƒˆ ë°ì´í„°ë§Œ ì¶”ê°€ í•™ìŠµ</p>
                    <small>ë¹ ë¥´ê³  íš¨ìœ¨ì </small>
                </div>
                <div class="mode-card" onclick="selectMode('full')">
                    <h4>ğŸ”ƒ ì „ì²´ ì¬í•™ìŠµ</h4>
                    <p>ëª¨ë“  ë°ì´í„°ë¡œ ì²˜ìŒë¶€í„° ë‹¤ì‹œ í•™ìŠµ</p>
                    <small>ë” ì •í™•í•˜ì§€ë§Œ ëŠë¦¼</small>
                </div>
            </div>
            
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="learningProgress">ëŒ€ê¸° ì¤‘</div>
                </div>
            </div>
            
            <div>
                <button class="btn-primary" onclick="analyzeNewData()">
                    ğŸ” ìƒˆ ë°ì´í„° ë¶„ì„
                </button>
                <button class="btn-primary" onclick="startIncrementalLearning()" disabled id="learnBtn">
                    ğŸš€ í•™ìŠµ ì‹œì‘
                </button>
                <button class="btn-info" onclick="exportModel()">
                    ğŸ’¾ ëª¨ë¸ ë‚´ë³´ë‚´ê¸°
                </button>
                <button class="btn-warning" onclick="rollbackModel()">
                    â†¶ ì´ì „ ë²„ì „ ë³µêµ¬
                </button>
            </div>
        </div>
        
        <!-- ë°ì´í„° ì¤‘ë³µ ê²€ì‚¬ -->
        <div class="data-validation">
            <h3>ğŸ” ë°ì´í„° ì¤‘ë³µ ê²€ì‚¬</h3>
            <div id="validationResults"></div>
        </div>
        
        <!-- ë°ì´í„° í’ˆì§ˆ ì§€í‘œ -->
        <div class="quality-metrics">
            <h3>ğŸ“Š ë°ì´í„° í’ˆì§ˆ ì§€í‘œ</h3>
            <div class="quality-item">
                <span>ë°ì´í„° ë‹¤ì–‘ì„±</span>
                <div class="quality-bar">
                    <div class="quality-fill quality-good" id="diversityScore" style="width: 0%"></div>
                </div>
                <span id="diversityText">0%</span>
            </div>
            <div class="quality-item">
                <span>ë¼ë²¨ ê· í˜•ë„</span>
                <div class="quality-bar">
                    <div class="quality-fill quality-fair" id="balanceScore" style="width: 0%"></div>
                </div>
                <span id="balanceText">0%</span>
            </div>
            <div class="quality-item">
                <span>íŠ¹ì§• ë¶„í¬</span>
                <div class="quality-bar">
                    <div class="quality-fill quality-excellent" id="distributionScore" style="width: 0%"></div>
                </div>
                <span id="distributionText">0%</span>
            </div>
        </div>
        
        <!-- í•™ìŠµ íˆìŠ¤í† ë¦¬ -->
        <div class="learning-history">
            <h3>ğŸ“ˆ í•™ìŠµ íˆìŠ¤í† ë¦¬</h3>
            <div id="learningHistoryList"></div>
        </div>
        
        <!-- ëª¨ë¸ ì„±ëŠ¥ ì°¨íŠ¸ -->
        <div class="performance-chart">
            <h3>ğŸ“ˆ ëª¨ë¸ ì„±ëŠ¥ ì¶”ì´</h3>
            <div class="chart-container" id="performanceChart"></div>
        </div>
    </div>
    
    <!-- ì•Œë¦¼ -->
    <div id="notification" class="notification"></div>
    
    <script>
        // ì „ì—­ ë³€ìˆ˜
        let currentModel = null;
        let learningHistory = [];
        let dataHash = new Set();
        let learningMode = 'incremental';
        let newDataFeatures = [];
        let modelVersions = [];
        
        // IndexedDB ê´€ë¦¬
        class LearningDataStore {
            constructor() {
                this.dbName = 'UILearningDB';
                this.version = 1;
                this.db = null;
            }
            
            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // í•™ìŠµ ë°ì´í„° ì €ì¥ì†Œ
                        if (!db.objectStoreNames.contains('learningData')) {
                            const store = db.createObjectStore('learningData', { keyPath: 'hash' });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                            store.createIndex('videoName', 'videoName', { unique: false });
                        }
                        
                        // ëª¨ë¸ ë²„ì „ ì €ì¥ì†Œ
                        if (!db.objectStoreNames.contains('modelVersions')) {
                            const store = db.createObjectStore('modelVersions', { keyPath: 'version' });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                        
                        // í•™ìŠµ íˆìŠ¤í† ë¦¬ ì €ì¥ì†Œ
                        if (!db.objectStoreNames.contains('learningHistory')) {
                            const store = db.createObjectStore('learningHistory', { keyPath: 'id', autoIncrement: true });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    };
                });
            }
            
            async saveData(hash, data) {
                const transaction = this.db.transaction(['learningData'], 'readwrite');
                const store = transaction.objectStore('learningData');
                await store.put({ hash, ...data, timestamp: Date.now() });
            }
            
            async getData(hash) {
                const transaction = this.db.transaction(['learningData'], 'readonly');
                const store = transaction.objectStore('learningData');
                return new Promise((resolve) => {
                    const request = store.get(hash);
                    request.onsuccess = () => resolve(request.result);
                });
            }
            
            async getAllData() {
                const transaction = this.db.transaction(['learningData'], 'readonly');
                const store = transaction.objectStore('learningData');
                return new Promise((resolve) => {
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                });
            }
            
            async saveModel(version, modelData, accuracy) {
                const transaction = this.db.transaction(['modelVersions'], 'readwrite');
                const store = transaction.objectStore('modelVersions');
                await store.put({
                    version,
                    modelData,
                    accuracy,
                    timestamp: Date.now()
                });
            }
            
            async getModel(version) {
                const transaction = this.db.transaction(['modelVersions'], 'readonly');
                const store = transaction.objectStore('modelVersions');
                return new Promise((resolve) => {
                    const request = store.get(version);
                    request.onsuccess = () => resolve(request.result);
                });
            }
            
            async saveHistory(historyData) {
                const transaction = this.db.transaction(['learningHistory'], 'readwrite');
                const store = transaction.objectStore('learningHistory');
                await store.add({ ...historyData, timestamp: Date.now() });
            }
            
            async getHistory() {
                const transaction = this.db.transaction(['learningHistory'], 'readonly');
                const store = transaction.objectStore('learningHistory');
                return new Promise((resolve) => {
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result.sort((a, b) => b.timestamp - a.timestamp));
                });
            }
        }
        
        const dataStore = new LearningDataStore();
        
        // ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', async () => {
            await dataStore.init();
            await loadDashboard();
            await loadLearningHistory();
            
            showNotification('ì‹œìŠ¤í…œì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
        });
        
        // ëŒ€ì‹œë³´ë“œ ë¡œë“œ
        async function loadDashboard() {
            const allData = await dataStore.getAllData();
            const history = await dataStore.getHistory();
            
            // ì´ ìƒ˜í”Œ ìˆ˜
            document.getElementById('totalSamples').textContent = allData.length;
            
            // ê³ ìœ  ë¹„ë””ì˜¤ ìˆ˜
            const uniqueVideos = new Set(allData.map(d => d.videoName)).size;
            document.getElementById('uniqueVideos').textContent = uniqueVideos;
            
            // ìµœì‹  ì •í™•ë„
            if (history.length > 0) {
                const latestAccuracy = history[0].accuracy || 0;
                document.getElementById('modelAccuracy').textContent = Math.round(latestAccuracy * 100) + '%';
            }
            
            // ëª¨ë¸ ë²„ì „
            const versionCount = history.length;
            document.getElementById('learningVersion').textContent = `v${versionCount}.0`;
        }
        
        // í•™ìŠµ íˆìŠ¤í† ë¦¬ ë¡œë“œ
        async function loadLearningHistory() {
            const history = await dataStore.getHistory();
            const listDiv = document.getElementById('learningHistoryList');
            listDiv.innerHTML = '';
            
            history.slice(0, 10).forEach(item => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                historyItem.innerHTML = `
                    <div class="history-info">
                        <strong>${item.videoName || 'ì•Œ ìˆ˜ ì—†ìŒ'}</strong>
                        <div class="history-date">${new Date(item.timestamp).toLocaleString()}</div>
                    </div>
                    <div class="history-stats">
                        <div class="stat-badge">ìƒ˜í”Œ +${item.newSamples || 0}</div>
                        <div class="stat-badge">ì •í™•ë„ ${Math.round((item.accuracy || 0) * 100)}%</div>
                    </div>
                `;
                listDiv.appendChild(historyItem);
            });
        }
        
        // í•™ìŠµ ëª¨ë“œ ì„ íƒ
        function selectMode(mode) {
            learningMode = mode;
            document.querySelectorAll('.mode-card').forEach(card => {
                card.classList.remove('active');
            });
            event.target.closest('.mode-card').classList.add('active');
        }
        
        // ìƒˆ ë°ì´í„° ë¶„ì„
        async function analyzeNewData() {
            const segmentFile = document.getElementById('newSegmentData').files[0];
            const videoFile = document.getElementById('newVideoFile').files[0];
            
            if (!segmentFile || !videoFile) {
                showNotification('íŒŒì¼ì„ ëª¨ë‘ ì„ íƒí•´ì£¼ì„¸ìš”.', 'warning');
                return;
            }
            
            showNotification('ë°ì´í„° ë¶„ì„ ì¤‘...', 'success');
            
            try {
                // JSON ë°ì´í„° ì½ê¸°
                const segmentData = JSON.parse(await readFile(segmentFile));
                
                // ë¹„ë””ì˜¤ í•´ì‹œ ìƒì„±
                const videoHash = await generateFileHash(videoFile);
                const videoName = videoFile.name;
                
                // ì¤‘ë³µ ê²€ì‚¬
                const existingData = await dataStore.getData(videoHash);
                if (existingData) {
                    showNotification('ì´ë¯¸ í•™ìŠµëœ ì˜ìƒì…ë‹ˆë‹¤.', 'warning');
                    updateValidationResults([{
                        name: videoName,
                        status: 'duplicate',
                        message: 'ì¤‘ë³µëœ ì˜ìƒ'
                    }]);
                    return;
                }
                
                // íŠ¹ì§• ì¶”ì¶œ (ê°„ë‹¨í•œ ì‹œë®¬ë ˆì´ì…˜)
                newDataFeatures = await extractFeaturesFromSegments(segmentData, videoFile);
                
                // ê²€ì¦ ê²°ê³¼ í‘œì‹œ
                updateValidationResults([{
                    name: videoName,
                    status: 'new',
                    message: `ìƒˆë¡œìš´ ë°ì´í„° (${newDataFeatures.length}ê°œ ìƒ˜í”Œ)`
                }]);
                
                // í’ˆì§ˆ ì§€í‘œ ì—…ë°ì´íŠ¸
                updateQualityMetrics(newDataFeatures);
                
                document.getElementById('learnBtn').disabled = false;
                showNotification('ë°ì´í„° ë¶„ì„ ì™„ë£Œ!', 'success');
                
            } catch (error) {
                showNotification('ë°ì´í„° ë¶„ì„ ì‹¤íŒ¨: ' + error.message, 'error');
            }
        }
        
        // ì ì§„ì  í•™ìŠµ ì‹œì‘
        async function startIncrementalLearning() {
            if (newDataFeatures.length === 0) {
                showNotification('ë¨¼ì € ìƒˆ ë°ì´í„°ë¥¼ ë¶„ì„í•´ì£¼ì„¸ìš”.', 'warning');
                return;
            }
            
            const progressBar = document.getElementById('learningProgress');
            progressBar.textContent = 'í•™ìŠµ ì¤€ë¹„ ì¤‘...';
            progressBar.style.width = '10%';
            
            try {
                let model;
                let existingData = [];
                
                if (learningMode === 'incremental' && currentModel) {
                    // ì ì§„ì  í•™ìŠµ: ê¸°ì¡´ ëª¨ë¸ ì‚¬ìš©
                    model = currentModel;
                    progressBar.textContent = 'ê¸°ì¡´ ëª¨ë¸ ë¡œë“œë¨';
                    progressBar.style.width = '20%';
                } else {
                    // ì „ì²´ ì¬í•™ìŠµ: ëª¨ë“  ë°ì´í„° ë¡œë“œ
                    existingData = await dataStore.getAllData();
                    model = createNewModel();
                    progressBar.textContent = 'ìƒˆ ëª¨ë¸ ìƒì„±ë¨';
                    progressBar.style.width = '30%';
                }
                
                // í•™ìŠµ ë°ì´í„° ì¤€ë¹„
                const allFeatures = learningMode === 'incremental' ? 
                    newDataFeatures : 
                    [...existingData.flatMap(d => d.features || []), ...newDataFeatures];
                
                progressBar.textContent = 'í•™ìŠµ ë°ì´í„° ì¤€ë¹„ë¨';
                progressBar.style.width = '40%';
                
                // ëª¨ë¸ í•™ìŠµ
                const accuracy = await trainModel(model, allFeatures, (progress) => {
                    const totalProgress = 40 + (progress * 50);
                    progressBar.textContent = `í•™ìŠµ ì¤‘... ${Math.round(progress * 100)}%`;
                    progressBar.style.width = totalProgress + '%';
                });
                
                // ìƒˆ ë°ì´í„° ì €ì¥
                const videoFile = document.getElementById('newVideoFile').files[0];
                const videoHash = await generateFileHash(videoFile);
                await dataStore.saveData(videoHash, {
                    videoName: videoFile.name,
                    features: newDataFeatures
                });
                
                // ëª¨ë¸ ì €ì¥
                const newVersion = `v${Date.now()}`;
                const modelData = await model.save('indexeddb://ui-model-' + newVersion);
                await dataStore.saveModel(newVersion, modelData, accuracy);
                
                // íˆìŠ¤í† ë¦¬ ì €ì¥
                await dataStore.saveHistory({
                    videoName: videoFile.name,
                    newSamples: newDataFeatures.length,
                    accuracy: accuracy,
                    mode: learningMode
                });
                
                currentModel = model;
                
                progressBar.textContent = 'í•™ìŠµ ì™„ë£Œ!';
                progressBar.style.width = '100%';
                
                // ëŒ€ì‹œë³´ë“œ ì—…ë°ì´íŠ¸
                await loadDashboard();
                await loadLearningHistory();
                
                showNotification(`í•™ìŠµ ì™„ë£Œ! ì •í™•ë„: ${Math.round(accuracy * 100)}%`, 'success');
                
                // ë³€í™”ëŸ‰ í‘œì‹œ
                const samplesChange = document.getElementById('samplesChange');
                samplesChange.textContent = `+${newDataFeatures.length} (ì´ë²ˆ ì„¸ì…˜)`;
                samplesChange.className = 'dashboard-change change-positive';
                
            } catch (error) {
                showNotification('í•™ìŠµ ì‹¤íŒ¨: ' + error.message, 'error');
                progressBar.textContent = 'í•™ìŠµ ì‹¤íŒ¨';
                progressBar.style.width = '0%';
            }
        }
        
        // íŒŒì¼ í•´ì‹œ ìƒì„±
        async function generateFileHash(file) {
            const buffer = await file.arrayBuffer();
            const wordArray = CryptoJS.lib.WordArray.create(buffer);
            return CryptoJS.SHA256(wordArray).toString();
        }
        
        // íŒŒì¼ ì½ê¸°
        function readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }
        
        // íŠ¹ì§• ì¶”ì¶œ ì‹œë®¬ë ˆì´ì…˜
        async function extractFeaturesFromSegments(segmentData, videoFile) {
            const features = [];
            
            // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë¹„ë””ì˜¤ í”„ë ˆì„ì„ ë¶„ì„
            segmentData.uiSegments.forEach(segment => {
                // UI ì‹œì‘
                features.push({
                    colorUniformity: 80 + Math.random() * 15,
                    textDensity: 85 + Math.random() * 10,
                    edgeDensity: 40 + Math.random() * 15,
                    layoutScore: 75 + Math.random() * 20,
                    label: 'ui_start',
                    time: segment.start
                });
                
                // UI ì¢…ë£Œ
                features.push({
                    colorUniformity: 82 + Math.random() * 12,
                    textDensity: 87 + Math.random() * 8,
                    edgeDensity: 38 + Math.random() * 18,
                    layoutScore: 78 + Math.random() * 17,
                    label: 'ui_end',
                    time: segment.end
                });
                
                // ê²Œì„ ì¤‘ê°„
                const midTime = (segment.start + segment.end) / 2;
                features.push({
                    colorUniformity: 40 + Math.random() * 20,
                    textDensity: 25 + Math.random() * 15,
                    edgeDensity: 75 + Math.random() * 20,
                    layoutScore: 35 + Math.random() * 25,
                    label: 'game',
                    time: midTime
                });
            });
            
            return features;
        }
        
        // ìƒˆ ëª¨ë¸ ìƒì„±
        function createNewModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [4], units: 16, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({ units: 8, activation: 'relu' }),
                    tf.layers.dense({ units: 3, activation: 'softmax' })
                ]
            });
            
            model.compile({
                optimizer: 'adam',
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });
            
            return model;
        }
        
        // ëª¨ë¸ í•™ìŠµ
        async function trainModel(model, features, progressCallback) {
            const xs = features.map(f => [f.colorUniformity, f.textDensity, f.edgeDensity, f.layoutScore]);
            const ys = features.map(f => {
                if (f.label === 'ui_start') return [1, 0, 0];
                if (f.label === 'ui_end') return [0, 1, 0];
                return [0, 0, 1];
            });
            
            const xTensor = tf.tensor2d(xs);
            const yTensor = tf.tensor2d(ys);
            
            const history = await model.fit(xTensor, yTensor, {
                epochs: 30,
                validationSplit: 0.2,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        const progress = (epoch + 1) / 30;
                        progressCallback(progress);
                    }
                }
            });
            
            xTensor.dispose();
            yTensor.dispose();
            
            const finalAccuracy = history.history.val_acc || history.history.acc;
            return finalAccuracy[finalAccuracy.length - 1];
        }
        
        // ê²€ì¦ ê²°ê³¼ ì—…ë°ì´íŠ¸
        function updateValidationResults(results) {
            const div = document.getElementById('validationResults');
            div.innerHTML = '';
            
            results.forEach(result => {
                const item = document.createElement('div');
                item.className = 'validation-item';
                item.innerHTML = `
                    <div>
                        <strong>${result.name}</strong><br>
                        <small>${result.message}</small>
                    </div>
                    <div class="status-${result.status}">${getStatusText(result.status)}</div>
                `;
                div.appendChild(item);
            });
        }
        
        // ìƒíƒœ í…ìŠ¤íŠ¸
        function getStatusText(status) {
            switch (status) {
                case 'new': return 'ìƒˆ ë°ì´í„°';
                case 'duplicate': return 'ì¤‘ë³µ';
                case 'similar': return 'ìœ ì‚¬í•¨';
                default: return 'ì•Œ ìˆ˜ ì—†ìŒ';
            }
        }
        
        // í’ˆì§ˆ ì§€í‘œ ì—…ë°ì´íŠ¸
        function updateQualityMetrics(features) {
            // ë°ì´í„° ë‹¤ì–‘ì„± (íŠ¹ì§•ê°’ì˜ ë¶„ì‚°)
            const diversityScore = calculateDiversity(features);
            document.getElementById('diversityScore').style.width = diversityScore + '%';
            document.getElementById('diversityText').textContent = Math.round(diversityScore) + '%';
            
            // ë¼ë²¨ ê· í˜•ë„
            const balanceScore = calculateBalance(features);
            document.getElementById('balanceScore').style.width = balanceScore + '%';
            document.getElementById('balanceText').textContent = Math.round(balanceScore) + '%';
            
            // íŠ¹ì§• ë¶„í¬
            const distributionScore = calculateDistribution(features);
            document.getElementById('distributionScore').style.width = distributionScore + '%';
            document.getElementById('distributionText').textContent = Math.round(distributionScore) + '%';
        }
        
        // ë‹¤ì–‘ì„± ê³„ì‚°
        function calculateDiversity(features) {
            const colorValues = features.map(f => f.colorUniformity);
            const variance = colorValues.reduce((sum, val) => {
                const mean = colorValues.reduce((a, b) => a + b) / colorValues.length;
                return sum + Math.pow(val - mean, 2);
            }, 0) / colorValues.length;
            
            return Math.min(100, variance * 2);
        }
        
        // ê· í˜•ë„ ê³„ì‚°
        function calculateBalance(features) {
            const labelCounts = {};
            features.forEach(f => {
                labelCounts[f.label] = (labelCounts[f.label] || 0) + 1;
            });
            
            const counts = Object.values(labelCounts);
            const maxCount = Math.max(...counts);
            const minCount = Math.min(...counts);
            
            return (minCount / maxCount) * 100;
        }
        
        // ë¶„í¬ ê³„ì‚°
        function calculateDistribution(features) {
            // íŠ¹ì§•ê°’ë“¤ì´ ê³ ë¥´ê²Œ ë¶„í¬ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
            const ranges = ['colorUniformity', 'textDensity', 'edgeDensity', 'layoutScore'];
            let totalCoverage = 0;
            
            ranges.forEach(range => {
                const values = features.map(f => f[range]);
                const min = Math.min(...values);
                const max = Math.max(...values);
                const coverage = (max - min) / 100; // 0-100 ë²”ìœ„ ê¸°ì¤€
                totalCoverage += coverage;
            });
            
            return (totalCoverage / ranges.length) * 100;
        }
        
        // ëª¨ë¸ ë‚´ë³´ë‚´ê¸°
        async function exportModel() {
            if (!currentModel) {
                showNotification('ë‚´ë³´ë‚¼ ëª¨ë¸ì´ ì—†ìŠµë‹ˆë‹¤.', 'warning');
                return;
            }
            
            try {
                await currentModel.save('downloads://ui-detection-model');
                showNotification('ëª¨ë¸ì´ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
            } catch (error) {
                showNotification('ëª¨ë¸ ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨: ' + error.message, 'error');
            }
        }
        
        // ëª¨ë¸ ë¡¤ë°±
        async function rollbackModel() {
            const history = await dataStore.getHistory();
            if (history.length < 2) {
                showNotification('ë¡¤ë°±í•  ì´ì „ ë²„ì „ì´ ì—†ìŠµë‹ˆë‹¤.', 'warning');
                return;
            }
            
            try {
                const previousVersion = history[1];
                const modelData = await dataStore.getModel(previousVersion.version);
                currentModel = await tf.loadLayersModel(modelData.modelData);
                
                showNotification('ì´ì „ ë²„ì „ìœ¼ë¡œ ë¡¤ë°±ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                await loadDashboard();
            } catch (error) {
                showNotification('ë¡¤ë°± ì‹¤íŒ¨: ' + error.message, 'error');
            }
        }
        
        // ì•Œë¦¼ í‘œì‹œ
        function showNotification(message, type) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type} show`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
    </script>
</body>
</html>