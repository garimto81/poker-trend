<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GFX 오버레이 학습기 - RFID Poker Graphics</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #0d1117;
            color: #c9d1d9;
        }
        .card {
            background-color: #161b22;
            border: 1px solid #30363d;
        }
        .btn-primary {
            background-color: #238636;
            border-color: #238636;
        }
        .btn-primary:hover {
            background-color: #2ea043;
            border-color: #2ea043;
        }
        .btn-danger {
            background-color: #f85149;
            border-color: #f85149;
        }
        #videoCanvas, #snapshotCanvas {
            max-width: 100%;
            border: 2px solid #30363d;
            border-radius: 6px;
            margin-bottom: 10px;
        }
        .snapshot-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }
        .snapshot-item {
            position: relative;
            border: 2px solid #30363d;
            border-radius: 6px;
            overflow: hidden;
        }
        .snapshot-item.gfx {
            border-color: #f85149;
        }
        .snapshot-item.game {
            border-color: #238636;
        }
        .snapshot-item img {
            width: 100%;
            height: auto;
        }
        .snapshot-label {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .snapshot-label.gfx {
            background-color: #f85149;
        }
        .snapshot-label.game {
            background-color: #238636;
        }
        .feature-display {
            background: #0d1117;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #30363d;
            font-family: monospace;
        }
        .progress {
            height: 25px;
            background-color: #0d1117;
        }
        .timeline-control {
            margin: 20px 0;
        }
        .btn-group-toggle .btn {
            background-color: #161b22;
            border-color: #30363d;
            color: #c9d1d9;
        }
        .btn-group-toggle .btn.active {
            background-color: #238636;
            border-color: #238636;
        }
        .alert-warning {
            background-color: #bb8009;
            border-color: #bb8009;
            color: white;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-dark bg-dark">
        <div class="container">
            <span class="navbar-brand mb-0 h1">🎰 GFX 오버레이 구간 분석기</span>
            <a href="../index.html" class="btn btn-outline-light btn-sm">메인으로</a>
        </div>
    </nav>

    <div class="container mt-4">
        <div class="alert alert-warning">
            <strong>구간 분석 방법:</strong> 영상을 재생하면서 GFX 오버레이가 나타나면 'GFX 오버레이 인식' 버튼을 클릭하여 시작점을 마킹하고, 
            GFX가 사라지면 다시 클릭하여 종료점을 마킹하세요. 
            시스템이 자동으로 시작점 -15초, 종료점 +15초로 핸드 구간을 계산합니다.
        </div>

        <div class="row">
            <div class="col-md-8">
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">비디오 학습</h5>
                        
                        <!-- 비디오 업로드 -->
                        <div class="mb-3">
                            <input type="file" class="form-control" id="videoInput" accept="video/*">
                        </div>
                        
                        <!-- 비디오 캔버스 -->
                        <canvas id="videoCanvas" width="800" height="450"></canvas>
                        
                        <!-- 비디오 컨트롤 -->
                        <div class="mt-3">
                            <div class="btn-toolbar" role="toolbar">
                                <div class="btn-group me-2" role="group">
                                    <button class="btn btn-secondary" id="playBtn" disabled>
                                        <i class="bi bi-play-fill"></i> 재생
                                    </button>
                                    <button class="btn btn-secondary" id="pauseBtn" disabled>
                                        <i class="bi bi-pause-fill"></i> 일시정지
                                    </button>
                                </div>
                                <div class="btn-group me-2" role="group">
                                    <button class="btn btn-secondary" id="skipBackBtn" disabled>
                                        <i class="bi bi-skip-backward-fill"></i> -5초
                                    </button>
                                    <button class="btn btn-secondary" id="skipForwardBtn" disabled>
                                        <i class="bi bi-skip-forward-fill"></i> +5초
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 타임라인 슬라이더 -->
                        <div class="timeline-control">
                            <input type="range" class="form-range" id="timelineSlider" 
                                   min="0" max="100" value="0" disabled>
                            <div class="d-flex justify-content-between">
                                <small id="currentTime">0:00</small>
                                <small id="totalTime">0:00</small>
                            </div>
                        </div>
                        
                        <!-- 마킹 버튼 -->
                        <div class="d-flex gap-2 mt-3">
                            <button class="btn btn-danger btn-lg flex-fill" id="markGFXBtn" disabled>
                                📺 GFX 오버레이 인식 (클릭: 시작점 마킹)
                            </button>
                        </div>
                        
                        <!-- 구간 정보 표시 -->
                        <div class="mt-3" id="segmentInfo" style="display: none;">
                            <div class="alert alert-info">
                                <strong>현재 구간:</strong> 
                                <span id="segmentStatus">대기 중</span><br>
                                <strong>시작점:</strong> <span id="segmentStart">-</span><br>
                                <strong>종료점:</strong> <span id="segmentEnd">-</span><br>
                                <strong>핸드 구간:</strong> <span id="handSegment">-</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-4">
                <!-- 현재 프레임 특징 -->
                <div class="card mb-3">
                    <div class="card-body">
                        <h5 class="card-title">현재 프레임 특징</h5>
                        <div class="feature-display">
                            <div>색상 균일도: <span id="colorUniformity">0.00</span></div>
                            <div>텍스트 밀도: <span id="textDensity">0.00</span></div>
                            <div>엣지 밀도: <span id="edgeDensity">0.00</span></div>
                            <div>정적 점수: <span id="staticScore">0.00</span></div>
                            <div class="mt-2">
                                <strong>예측: <span id="prediction">-</span></strong>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 구간 통계 -->
                <div class="card mb-3">
                    <div class="card-body">
                        <h5 class="card-title">구간 통계</h5>
                        <div class="stats-box">
                            <div class="d-flex justify-content-between mb-2">
                                <span>GFX 구간 수:</span>
                                <span id="gfxCount" class="text-danger">0</span>
                            </div>
                            <div class="d-flex justify-content-between mb-2">
                                <span>총 핸드 시간:</span>
                                <span id="gameCount" class="text-success">0:00</span>
                            </div>
                            <div class="d-flex justify-content-between mb-2">
                                <span>총 구간:</span>
                                <span id="totalSamples">0 구간</span>
                            </div>
                            <div class="progress mt-3">
                                <div class="progress-bar bg-danger" id="gfxProgress" style="width: 0%"></div>
                                <div class="progress-bar bg-success" id="gameProgress" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 구간 관리 -->
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">구간 관리</h5>
                        <div class="d-grid gap-2">
                            <button class="btn btn-success" id="saveBtn" disabled>
                                💾 구간 데이터 내보내기 (JSON)
                            </button>
                            <button class="btn btn-secondary" id="loadBtn">
                                📂 구간 데이터 불러오기
                            </button>
                            <button class="btn btn-outline-danger" id="clearBtn">
                                🗑️ 모든 구간 초기화
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 마킹된 구간 목록 -->
        <div class="row mt-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">마킹된 구간 목록</h5>
                        <div class="snapshot-grid" id="snapshotGrid">
                            <!-- 구간 정보가 동적으로 추가됨 -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 전역 변수
        let video = null;
        let canvas = null;
        let ctx = null;
        let segments = [];  // 구간 정보 저장
        let currentSegment = null;  // 현재 마킹 중인 구간
        let isMarkingStart = true;  // true: 시작점 마킹, false: 종료점 마킹
        let model = null;
        let isPlaying = false;
        let animationId = null;
        
        // 초기화
        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('videoCanvas');
            ctx = canvas.getContext('2d');
            
            // 이벤트 리스너
            document.getElementById('videoInput').addEventListener('change', handleVideoUpload);
            document.getElementById('playBtn').addEventListener('click', playVideo);
            document.getElementById('pauseBtn').addEventListener('click', pauseVideo);
            document.getElementById('skipBackBtn').addEventListener('click', () => skipVideo(-5));
            document.getElementById('skipForwardBtn').addEventListener('click', () => skipVideo(5));
            document.getElementById('timelineSlider').addEventListener('input', handleTimelineChange);
            
            document.getElementById('markGFXBtn').addEventListener('click', toggleGFXMarking);
            
            document.getElementById('saveBtn').addEventListener('click', saveModel);
            document.getElementById('loadBtn').addEventListener('click', loadModel);
            document.getElementById('clearBtn').addEventListener('click', clearSamples);
            
            // 저장된 샘플 로드
            loadSamplesFromStorage();
        });
        
        // 비디오 업로드 처리
        function handleVideoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.addEventListener('loadedmetadata', () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // 버튼 활성화
                document.getElementById('playBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('skipBackBtn').disabled = false;
                document.getElementById('skipForwardBtn').disabled = false;
                document.getElementById('timelineSlider').disabled = false;
                document.getElementById('markGFXBtn').disabled = false;
                
                // 타임라인 설정
                document.getElementById('timelineSlider').max = video.duration;
                document.getElementById('totalTime').textContent = formatTime(video.duration);
                
                // 첫 프레임 표시
                video.currentTime = 0;
                drawFrame();
            });
            
            video.addEventListener('timeupdate', updateTimeline);
        }
        
        // 비디오 재생
        function playVideo() {
            if (!video) return;
            video.play();
            isPlaying = true;
            animate();
        }
        
        // 비디오 일시정지
        function pauseVideo() {
            if (!video) return;
            video.pause();
            isPlaying = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        // 비디오 스킵
        function skipVideo(seconds) {
            if (!video) return;
            video.currentTime = Math.max(0, Math.min(video.duration, video.currentTime + seconds));
            drawFrame();
        }
        
        // 타임라인 변경 처리
        function handleTimelineChange(event) {
            if (!video) return;
            video.currentTime = parseFloat(event.target.value);
            drawFrame();
        }
        
        // 타임라인 업데이트
        function updateTimeline() {
            if (!video) return;
            document.getElementById('timelineSlider').value = video.currentTime;
            document.getElementById('currentTime').textContent = formatTime(video.currentTime);
        }
        
        // 애니메이션 루프
        function animate() {
            if (isPlaying) {
                drawFrame();
                animationId = requestAnimationFrame(animate);
            }
        }
        
        // 프레임 그리기 및 특징 분석
        function drawFrame() {
            if (!video) return;
            
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            analyzeFrame();
        }
        
        // 프레임 분석
        function analyzeFrame() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const features = extractFeatures(imageData);
            
            // UI 업데이트
            document.getElementById('colorUniformity').textContent = features.colorUniformity.toFixed(2);
            document.getElementById('textDensity').textContent = features.textDensity.toFixed(2);
            document.getElementById('edgeDensity').textContent = features.edgeDensity.toFixed(2);
            document.getElementById('staticScore').textContent = features.staticScore.toFixed(2);
            
            // 예측 (모델이 있는 경우)
            if (model) {
                const prediction = predictFrame(features);
                document.getElementById('prediction').textContent = 
                    prediction > 0.5 ? 'GFX 오버레이' : '게임 화면';
                document.getElementById('prediction').style.color = 
                    prediction > 0.5 ? '#f85149' : '#238636';
            }
        }
        
        // 특징 추출
        function extractFeatures(imageData) {
            const data = imageData.data;
            
            // 색상 균일도
            const colorUniformity = calculateColorUniformity(data);
            
            // 텍스트 밀도 (엣지 기반 추정)
            const textDensity = estimateTextDensity(data, imageData.width, imageData.height);
            
            // 엣지 밀도
            const edgeDensity = calculateEdgeDensity(data, imageData.width, imageData.height);
            
            // 정적 점수 (프레임 간 차이로 추정)
            const staticScore = 0.5; // 실제로는 이전 프레임과 비교
            
            return {
                colorUniformity,
                textDensity,
                edgeDensity,
                staticScore,
                timestamp: video ? video.currentTime : 0
            };
        }
        
        // 색상 균일도 계산
        function calculateColorUniformity(data) {
            const colorMap = {};
            const sampleRate = 100;
            
            for (let i = 0; i < data.length; i += sampleRate * 4) {
                const r = Math.floor(data[i] / 32) * 32;
                const g = Math.floor(data[i + 1] / 32) * 32;
                const b = Math.floor(data[i + 2] / 32) * 32;
                const color = `${r},${g},${b}`;
                
                colorMap[color] = (colorMap[color] || 0) + 1;
            }
            
            const colors = Object.values(colorMap).sort((a, b) => b - a);
            const top5 = colors.slice(0, 5).reduce((a, b) => a + b, 0);
            const total = colors.reduce((a, b) => a + b, 0);
            
            return total > 0 ? top5 / total : 0;
        }
        
        // 텍스트 밀도 추정
        function estimateTextDensity(data, width, height) {
            let highContrastCount = 0;
            const threshold = 100;
            
            for (let y = 0; y < height - 1; y++) {
                for (let x = 0; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const idx_right = idx + 4;
                    const idx_down = idx + width * 4;
                    
                    // 수평 엣지
                    const diffH = Math.abs(data[idx] - data[idx_right]) +
                                  Math.abs(data[idx + 1] - data[idx_right + 1]) +
                                  Math.abs(data[idx + 2] - data[idx_right + 2]);
                    
                    // 수직 엣지
                    const diffV = Math.abs(data[idx] - data[idx_down]) +
                                  Math.abs(data[idx + 1] - data[idx_down + 1]) +
                                  Math.abs(data[idx + 2] - data[idx_down + 2]);
                    
                    if (diffH > threshold || diffV > threshold) {
                        highContrastCount++;
                    }
                }
            }
            
            return highContrastCount / (width * height);
        }
        
        // 엣지 밀도 계산
        function calculateEdgeDensity(data, width, height) {
            let edgeCount = 0;
            const threshold = 50;
            
            for (let i = 0; i < data.length - 4; i += 4) {
                const diff = Math.abs(data[i] - data[i + 4]);
                if (diff > threshold) edgeCount++;
            }
            
            return edgeCount / (data.length / 4);
        }
        
        // GFX 마킹 토글
        function toggleGFXMarking() {
            if (!video) {
                alert('비디오를 먼저 업로드해주세요.');
                return;
            }
            
            const btn = document.getElementById('markGFXBtn');
            const segmentInfo = document.getElementById('segmentInfo');
            
            if (isMarkingStart) {
                // 시작점 마킹
                currentSegment = {
                    gfxStart: video.currentTime,
                    gfxEnd: null,
                    handStart: null,
                    handEnd: null,
                    id: Date.now()
                };
                
                // 버튼 상태 변경
                btn.textContent = '📺 GFX 오버레이 인식 (클릭: 종료점 마킹)';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-warning');
                
                // 구간 정보 표시
                segmentInfo.style.display = 'block';
                document.getElementById('segmentStatus').textContent = 'GFX 구간 마킹 중...';
                document.getElementById('segmentStart').textContent = formatTime(currentSegment.gfxStart);
                document.getElementById('segmentEnd').textContent = '대기 중...';
                
                isMarkingStart = false;
                
            } else {
                // 종료점 마킹
                if (!currentSegment) return;
                
                currentSegment.gfxEnd = video.currentTime;
                
                // 15초 규칙 적용하여 핸드 구간 계산
                currentSegment.handStart = Math.max(0, currentSegment.gfxStart - 15);
                currentSegment.handEnd = Math.min(video.duration || 3600, currentSegment.gfxEnd + 15);
                
                // 구간 저장
                segments.push(currentSegment);
                console.log('구간 저장됨:', currentSegment);
                console.log('전체 구간 수:', segments.length);
                
                // 버튼 상태 초기화
                btn.textContent = '📺 GFX 오버레이 인식 (클릭: 시작점 마킹)';
                btn.classList.remove('btn-warning');
                btn.classList.add('btn-danger');
                
                // 구간 정보 업데이트
                document.getElementById('segmentStatus').textContent = '구간 저장 완료!';
                document.getElementById('segmentEnd').textContent = formatTime(currentSegment.gfxEnd);
                document.getElementById('handSegment').textContent = 
                    `${formatTime(currentSegment.handStart)} ~ ${formatTime(currentSegment.handEnd)}`;
                
                // 시각적 피드백
                btn.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    btn.style.transform = 'scale(1)';
                    updateSegmentDisplay();
                    saveSegmentsToStorage();
                }, 100);
                
                currentSegment = null;
                isMarkingStart = true;
            }
        }
        
        // 구간 표시 업데이트
        function updateSegmentDisplay() {
            console.log('updateSegmentDisplay 호출됨, segments:', segments);
            const grid = document.getElementById('snapshotGrid');
            grid.innerHTML = '';
            
            segments.forEach((segment, index) => {
                console.log(`구간 ${index}:`, segment);
                const item = document.createElement('div');
                item.className = 'card mb-2';
                item.style.backgroundColor = '#161b22';
                item.innerHTML = `
                    <div class="card-body">
                        <h6 class="card-title text-danger">구간 ${index + 1}</h6>
                        <div class="row">
                            <div class="col-md-6">
                                <small class="text-muted">GFX 오버레이 구간:</small><br>
                                <span class="text-warning">${formatTime(segment.gfxStart)} ~ ${formatTime(segment.gfxEnd)}</span>
                            </div>
                            <div class="col-md-6">
                                <small class="text-muted">핸드 구간 (±15초):</small><br>
                                <span class="text-success">${formatTime(segment.handStart)} ~ ${formatTime(segment.handEnd)}</span>
                            </div>
                        </div>
                        <div class="mt-2">
                            <small class="text-muted">길이: ${formatTime(segment.handEnd - segment.handStart)}</small>
                            <button class="btn btn-sm btn-danger float-end" onclick="removeSegment('${segment.id}')">
                                삭제
                            </button>
                            <button class="btn btn-sm btn-info float-end me-2" onclick="jumpToSegment(${segment.gfxStart})">
                                이동
                            </button>
                        </div>
                    </div>
                `;
                grid.appendChild(item);
            });
            
            updateStats();
        }
        
        // 구간 제거
        function removeSegment(id) {
            segments = segments.filter(s => s.id != id);
            updateSegmentDisplay();
            saveSegmentsToStorage();
        }
        
        // 구간으로 이동
        function jumpToSegment(time) {
            if (video) {
                video.currentTime = time;
                drawFrame();
            }
        }
        
        // 통계 업데이트
        function updateStats() {
            const totalSegments = segments.length;
            let totalGFXTime = 0;
            let totalHandTime = 0;
            
            segments.forEach(segment => {
                totalGFXTime += (segment.gfxEnd - segment.gfxStart);
                totalHandTime += (segment.handEnd - segment.handStart);
            });
            
            document.getElementById('gfxCount').textContent = totalSegments;
            document.getElementById('gameCount').textContent = formatTime(totalHandTime);
            document.getElementById('totalSamples').textContent = totalSegments + ' 구간';
            
            if (video && video.duration > 0) {
                const gfxPercent = (totalGFXTime / video.duration) * 100;
                const handPercent = (totalHandTime / video.duration) * 100;
                document.getElementById('gfxProgress').style.width = `${Math.min(gfxPercent, 100)}%`;
                document.getElementById('gameProgress').style.width = `${Math.min(handPercent, 100)}%`;
            } else {
                document.getElementById('gfxProgress').style.width = '0%';
                document.getElementById('gameProgress').style.width = '0%';
            }
            
            // 내보내기 버튼 활성화
            if (totalSegments > 0) {
                document.getElementById('saveBtn').disabled = false;
            }
        }
        
        
        // 평균 특징 계산
        function calculateAverageFeatures(samples) {
            if (samples.length === 0) return null;
            
            const sum = samples.reduce((acc, sample) => {
                acc.colorUniformity += sample.features.colorUniformity;
                acc.textDensity += sample.features.textDensity;
                acc.edgeDensity += sample.features.edgeDensity;
                acc.staticScore += sample.features.staticScore;
                return acc;
            }, { colorUniformity: 0, textDensity: 0, edgeDensity: 0, staticScore: 0 });
            
            const count = samples.length;
            return {
                colorUniformity: sum.colorUniformity / count,
                textDensity: sum.textDensity / count,
                edgeDensity: sum.edgeDensity / count,
                staticScore: sum.staticScore / count
            };
        }
        
        // 프레임 예측
        function predictFrame(features) {
            if (!model) return 0.5;
            
            // 간단한 유사도 기반 예측
            let maxSimilarity = 0;
            
            for (const pattern of model.patterns) {
                const similarity = calculateSimilarity(features, pattern);
                maxSimilarity = Math.max(maxSimilarity, similarity);
            }
            
            return maxSimilarity;
        }
        
        // 유사도 계산
        function calculateSimilarity(f1, f2) {
            const colorDiff = Math.abs(f1.colorUniformity - f2.colorUniformity);
            const textDiff = Math.abs(f1.textDensity - f2.textDensity);
            const edgeDiff = Math.abs(f1.edgeDensity - f2.edgeDensity);
            
            // 역 거리 (가까울수록 1에 가까움)
            const avgDiff = (colorDiff + textDiff + edgeDiff) / 3;
            return 1 - Math.min(avgDiff, 1);
        }
        
        // 구간 데이터 저장
        function saveModel() {
            if (segments.length === 0) {
                alert('저장할 구간이 없습니다.');
                return;
            }
            
            // JSON 형식으로 내보내기
            const exportData = {
                version: '2.0',
                type: 'segment-analysis',
                segments: segments.map(s => ({
                    gfxStart: s.gfxStart,
                    gfxEnd: s.gfxEnd,
                    handStart: s.handStart,
                    handEnd: s.handEnd,
                    duration: s.handEnd - s.handStart
                })),
                totalSegments: segments.length,
                videoInfo: {
                    duration: video ? video.duration : 0,
                    filename: document.getElementById('videoInput').files[0]?.name || 'unknown'
                },
                createdAt: new Date().toISOString()
            };
            
            // 다운로드 링크 생성
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gfx_segments_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            alert(`${segments.length}개 구간이 JSON 파일로 저장되었습니다!`);
        }
        
        // 구간 데이터 불러오기
        function loadModel() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.segments && Array.isArray(data.segments)) {
                            segments = data.segments.map(s => ({
                                ...s,
                                id: Date.now() + Math.random()
                            }));
                            updateSegmentDisplay();
                            saveSegmentsToStorage();
                            alert(`${segments.length}개 구간을 불러왔습니다!`);
                        } else {
                            alert('유효한 구간 데이터가 아닙니다.');
                        }
                    } catch (error) {
                        alert('파일을 읽을 수 없습니다.');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // 구간 초기화
        function clearSamples() {
            if (confirm('모든 구간을 삭제하시겠습니까?')) {
                segments = [];
                updateSegmentDisplay();
                saveSegmentsToStorage();
                document.getElementById('saveBtn').disabled = true;
                
                // 현재 마킹 중인 구간도 초기화
                if (currentSegment) {
                    currentSegment = null;
                    isMarkingStart = true;
                    const btn = document.getElementById('markGFXBtn');
                    btn.textContent = '📺 GFX 오버레이 인식 (클릭: 시작점 마킹)';
                    btn.classList.remove('btn-warning');
                    btn.classList.add('btn-danger');
                    document.getElementById('segmentInfo').style.display = 'none';
                }
            }
        }
        
        // 로컬 스토리지에 구간 저장
        function saveSegmentsToStorage() {
            localStorage.setItem('gfxSegments', JSON.stringify(segments));
        }
        
        // 로컬 스토리지에서 구간 로드
        function loadSamplesFromStorage() {
            const saved = localStorage.getItem('gfxSegments');
            if (saved) {
                try {
                    segments = JSON.parse(saved);
                    if (segments.length > 0) {
                        updateSegmentDisplay();
                        document.getElementById('saveBtn').disabled = false;
                    }
                } catch (error) {
                    segments = [];
                }
            }
        }
        
        // 시간 포맷
        function formatTime(seconds) {
            // null, undefined, NaN 처리
            if (seconds == null || isNaN(seconds) || seconds < 0) {
                return '0:00';
            }
            
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
    </script>
</body>
</html>