<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>온라인 UI 학습 시스템 - Archive-MAM</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            line-height: 1.6;
        }
        
        .header {
            background: #1a1a2e;
            padding: 20px;
            text-align: center;
            border-bottom: 3px solid #16213e;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #3498db, #2ecc71);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        @media (max-width: 968px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .section {
            background: #1a1a2e;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .section h3 {
            margin-bottom: 15px;
            color: #3498db;
        }
        
        .video-container {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        
        video {
            width: 100%;
            height: auto;
            border-radius: 8px;
            background: #000;
            display: block;
        }
        
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .file-input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 2px dashed #3498db;
            border-radius: 8px;
            background: rgba(52, 152, 219, 0.1);
            cursor: pointer;
        }
        
        .btn {
            background: linear-gradient(45deg, #3498db, #2ecc71);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
            display: inline-block;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .btn.danger {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }
        
        .btn.success {
            background: linear-gradient(45deg, #2ecc71, #27ae60);
        }
        
        .btn.active {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        
        .feature-cell {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .feature-cell.high {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.2);
        }
        
        .feature-cell.medium {
            border-color: #f39c12;
            background: rgba(243, 156, 18, 0.2);
        }
        
        .feature-cell.low {
            border-color: #3498db;
            background: rgba(52, 152, 219, 0.2);
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #2c3e50;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #3498db, #2ecc71);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        .timeline {
            height: 60px;
            background: #0f3460;
            border-radius: 30px;
            position: relative;
            margin: 20px 0;
            overflow: hidden;
            cursor: pointer;
        }
        
        .timeline-segment {
            position: absolute;
            height: 100%;
            background: #e74c3c;
            opacity: 0.8;
        }
        
        .timeline-cursor {
            position: absolute;
            width: 2px;
            height: 100%;
            background: #f39c12;
            top: 0;
            transition: left 0.1s;
        }
        
        .stats-card {
            background: #0f3460;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            margin: 10px 0;
        }
        
        .stats-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #3498db;
            margin: 10px 0;
        }
        
        .sample-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        
        .sample-thumb {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.3s;
            background: #0f3460;
            aspect-ratio: 16/9;
        }
        
        .sample-thumb:hover {
            transform: scale(1.05);
        }
        
        .sample-thumb canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .sample-label {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            background: rgba(0,0,0,0.8);
        }
        
        .sample-label.ui {
            background: #e74c3c;
        }
        
        .sample-label.game {
            background: #3498db;
        }
        
        .feature-importance {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .feature-bar {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        
        .feature-name {
            flex: 1;
            font-size: 14px;
        }
        
        .feature-score {
            width: 150px;
            height: 20px;
            background: #2c3e50;
            border-radius: 10px;
            overflow: hidden;
            margin-left: 10px;
        }
        
        .feature-score-fill {
            height: 100%;
            background: linear-gradient(to right, #f39c12, #e74c3c);
            transition: width 0.5s;
        }
        
        .alert {
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            background: #16213e;
            border-left: 4px solid #3498db;
        }
        
        .alert.success {
            border-color: #2ecc71;
            background: rgba(46, 204, 113, 0.1);
        }
        
        .alert.error {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #16213e;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .control-group {
            margin: 15px 0;
            padding: 15px;
            background: #0f3460;
            border-radius: 8px;
        }
        
        .control-group h4 {
            margin-bottom: 10px;
            color: #2ecc71;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🧠 온라인 UI 학습 시스템</h1>
        <p>1초에 1프레임 분석으로 정교한 UI 감지 학습 - 서버 없이 브라우저에서 작동</p>
    </div>
    
    <div class="container">
        <!-- 사용 안내 -->
        <div class="alert">
            <strong>💡 사용 방법:</strong> 포커 영상을 업로드하고 1초마다 자동 분석되는 프레임을 UI/게임으로 표시하여 학습 데이터를 만드세요. 
            모든 처리는 브라우저에서 이루어지며 서버로 전송되지 않습니다.
        </div>
        
        <div class="main-grid">
            <!-- 비디오 분석 섹션 -->
            <div class="section">
                <h3>📹 비디오 분석</h3>
                
                <input type="file" id="videoFile" accept="video/*" class="file-input">
                
                <div class="video-container">
                    <video id="video" controls></video>
                    <canvas class="grid-overlay" id="gridOverlay"></canvas>
                </div>
                
                <!-- 타임라인 -->
                <div class="timeline" id="timeline">
                    <div class="timeline-cursor" id="timelineCursor"></div>
                </div>
                
                <!-- 실시간 특징 분석 -->
                <h4>🔍 실시간 특징 분석 (1초마다 자동 업데이트)</h4>
                <div class="feature-grid" id="featureGrid">
                    <div class="feature-cell" id="motion">
                        <strong>움직임</strong>
                        <div class="value">-</div>
                    </div>
                    <div class="feature-cell" id="text">
                        <strong>텍스트</strong>
                        <div class="value">-</div>
                    </div>
                    <div class="feature-cell" id="color">
                        <strong>색상 균일도</strong>
                        <div class="value">-</div>
                    </div>
                    <div class="feature-cell" id="edge">
                        <strong>엣지 밀도</strong>
                        <div class="value">-</div>
                    </div>
                    <div class="feature-cell" id="layout">
                        <strong>레이아웃</strong>
                        <div class="value">-</div>
                    </div>
                    <div class="feature-cell" id="entropy">
                        <strong>엔트로피</strong>
                        <div class="value">-</div>
                    </div>
                </div>
                
                <!-- 진행률 -->
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar" style="width: 0%">0%</div>
                </div>
                
                <!-- 컨트롤 버튼 -->
                <div style="text-align: center;">
                    <button class="btn" id="startBtn" onclick="startAnalysis()">
                        🚀 분석 시작 (1초 1프레임)
                    </button>
                    <button class="btn danger" onclick="stopAnalysis()">
                        ⏹️ 분석 중지
                    </button>
                    <button class="btn success" onclick="markAsUI()">
                        ✅ 현재 프레임 UI로 표시
                    </button>
                    <button class="btn" onclick="markAsGame()">
                        🎮 현재 프레임 게임으로 표시
                    </button>
                </div>
            </div>
            
            <!-- 학습 컨트롤 섹션 -->
            <div class="section">
                <h3>🎛️ 학습 컨트롤</h3>
                
                <!-- 탭 메뉴 -->
                <div class="tabs">
                    <div class="tab active" onclick="showTab('stats')">통계</div>
                    <div class="tab" onclick="showTab('samples')">샘플</div>
                    <div class="tab" onclick="showTab('model')">모델</div>
                </div>
                
                <!-- 통계 탭 -->
                <div id="statsTab" class="tab-content active">
                    <div class="stats-card">
                        <div>전체 샘플</div>
                        <div class="stats-value" id="totalSamples">0</div>
                    </div>
                    <div class="stats-card">
                        <div>UI 샘플</div>
                        <div class="stats-value" id="uiSamples">0</div>
                    </div>
                    <div class="stats-card">
                        <div>게임 샘플</div>
                        <div class="stats-value" id="gameSamples">0</div>
                    </div>
                </div>
                
                <!-- 샘플 탭 -->
                <div id="samplesTab" class="tab-content">
                    <h4>🖼️ 수집된 샘플</h4>
                    <div class="sample-grid" id="sampleGrid"></div>
                </div>
                
                <!-- 모델 탭 -->
                <div id="modelTab" class="tab-content">
                    <div class="control-group">
                        <h4>🧠 모델 학습</h4>
                        <p id="modelStatus">최소 20개의 샘플이 필요합니다</p>
                        <button class="btn success" onclick="trainModel()">
                            모델 학습 시작
                        </button>
                    </div>
                    
                    <div class="feature-importance" id="featureImportance">
                        <h4>📊 특징 중요도</h4>
                        <p style="text-align: center; color: #7f8c8d;">
                            모델 학습 후 표시됩니다
                        </p>
                    </div>
                    
                    <div class="control-group">
                        <h4>💾 데이터 관리</h4>
                        <button class="btn" onclick="exportData()">
                            📥 학습 데이터 내보내기
                        </button>
                        <button class="btn" onclick="importData()">
                            📤 학습 데이터 가져오기
                        </button>
                        <button class="btn" onclick="saveToLocalStorage()">
                            💾 브라우저에 저장
                        </button>
                        <button class="btn danger" onclick="clearData()">
                            🗑️ 데이터 초기화
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 결과 섹션 -->
        <div class="section" style="margin-top: 20px;">
            <h3>📊 분석 결과</h3>
            <div id="results"></div>
        </div>
    </div>

    <!-- TensorFlow.js for ML -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    
    <script>
        // 전역 변수
        let video = null;
        let isAnalyzing = false;
        let frameInterval = null;
        let currentFrame = null;
        let collectedSamples = [];
        let model = null;
        let features = [];
        let labels = [];
        let gridOverlay = null;
        let gridCtx = null;
        let showGrid = false;
        
        // 초기화
        document.addEventListener('DOMContentLoaded', () => {
            video = document.getElementById('video');
            gridOverlay = document.getElementById('gridOverlay');
            gridCtx = gridOverlay.getContext('2d');
            
            // 파일 선택
            document.getElementById('videoFile').addEventListener('change', handleFileSelect);
            
            // 비디오 로드 완료
            video.addEventListener('loadedmetadata', () => {
                // 그리드 오버레이 크기를 비디오 크기에 맞춤
                resizeGridOverlay();
                initializeTimeline();
            });
            
            // 비디오 크기 변경 시
            video.addEventListener('resize', resizeGridOverlay);
            window.addEventListener('resize', resizeGridOverlay);
            
            // 타임라인 클릭
            document.getElementById('timeline').addEventListener('click', handleTimelineClick);
            
            // 로컬 스토리지에서 데이터 로드
            loadFromLocalStorage();
        });
        
        // 그리드 오버레이 크기 조정
        function resizeGridOverlay() {
            if (!video || !gridOverlay) return;
            
            // 비디오의 실제 표시 크기 가져오기
            const rect = video.getBoundingClientRect();
            gridOverlay.width = rect.width;
            gridOverlay.height = rect.height;
            
            // 그리드 다시 그리기
            if (showGrid && currentFrame) {
                drawFeatureGrid(currentFrame.features);
            }
        }
        
        // 파일 선택 처리
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                video.src = URL.createObjectURL(file);
                video.load();
            }
        }
        
        // 분석 시작
        function startAnalysis() {
            if (!video.src) {
                alert('먼저 비디오를 선택해주세요.');
                return;
            }
            
            isAnalyzing = true;
            video.play();
            
            document.getElementById('startBtn').classList.add('active');
            document.getElementById('startBtn').textContent = '🔄 분석 중...';
            
            // 1초마다 프레임 분석
            frameInterval = setInterval(analyzeCurrentFrame, 1000);
        }
        
        // 분석 중지
        function stopAnalysis() {
            isAnalyzing = false;
            video.pause();
            
            if (frameInterval) {
                clearInterval(frameInterval);
                frameInterval = null;
            }
            
            // 그리드 숨기기
            showGrid = false;
            if (gridCtx && gridOverlay) {
                gridCtx.clearRect(0, 0, gridOverlay.width, gridOverlay.height);
            }
            
            document.getElementById('startBtn').classList.remove('active');
            document.getElementById('startBtn').textContent = '🚀 분석 시작 (1초 1프레임)';
        }
        
        // 현재 프레임 분석
        function analyzeCurrentFrame() {
            if (!isAnalyzing || video.paused || video.ended) {
                stopAnalysis();
                return;
            }
            
            // Canvas에 현재 프레임 캡처
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);
            
            // 특징 추출
            const frameFeatures = extractFeatures(canvas, ctx);
            
            // UI 확률 예측 (모델이 있으면)
            if (model) {
                predictUI(frameFeatures);
            }
            
            // 시각화 업데이트
            updateFeatureVisualization(frameFeatures);
            
            // 그리드 표시
            showGrid = true;
            drawFeatureGrid(frameFeatures);
            
            // 진행률 업데이트
            updateProgress();
            
            // 현재 프레임 정보 저장
            currentFrame = {
                timestamp: video.currentTime,
                canvas: canvas,
                features: frameFeatures
            };
        }
        
        // 특징 그리드 그리기
        function drawFeatureGrid(features) {
            if (!gridCtx || !gridOverlay) return;
            
            // 캔버스 클리어
            gridCtx.clearRect(0, 0, gridOverlay.width, gridOverlay.height);
            
            // 3x3 그리드 그리기
            const cellWidth = gridOverlay.width / 3;
            const cellHeight = gridOverlay.height / 3;
            
            // 각 셀에 대해
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const x = col * cellWidth;
                    const y = row * cellHeight;
                    
                    // 셀 경계선
                    gridCtx.strokeStyle = 'rgba(52, 152, 219, 0.5)';
                    gridCtx.lineWidth = 2;
                    gridCtx.strokeRect(x, y, cellWidth, cellHeight);
                    
                    // 각 영역의 특성에 따라 색상 표시
                    const regionIndex = row * 3 + col;
                    const regionScore = getRegionScore(regionIndex, features);
                    
                    if (regionScore > 0.7) {
                        gridCtx.fillStyle = 'rgba(231, 76, 60, 0.3)';
                    } else if (regionScore > 0.4) {
                        gridCtx.fillStyle = 'rgba(243, 156, 18, 0.3)';
                    } else {
                        gridCtx.fillStyle = 'rgba(52, 152, 219, 0.1)';
                    }
                    
                    gridCtx.fillRect(x, y, cellWidth, cellHeight);
                    
                    // 영역 번호와 점수 표시
                    gridCtx.fillStyle = 'white';
                    gridCtx.font = '16px Arial';
                    gridCtx.textAlign = 'center';
                    gridCtx.textBaseline = 'middle';
                    gridCtx.fillText(
                        `${regionIndex + 1}: ${(regionScore * 100).toFixed(0)}%`,
                        x + cellWidth / 2,
                        y + cellHeight / 2
                    );
                }
            }
        }
        
        // 영역별 점수 계산 (간소화)
        function getRegionScore(regionIndex, features) {
            // 여기서는 간단히 특징들의 평균값을 사용
            const scores = [
                features.motion || 0,
                features.text || 0,
                features.color || 0,
                features.edge || 0,
                features.layout || 0,
                features.entropy || 0
            ];
            
            // 각 영역마다 약간 다른 가중치 적용
            const weight = (regionIndex + 1) / 10;
            return Math.min(scores[regionIndex % scores.length] + weight * 0.1, 1);
        }
        
        // 특징 추출 (브라우저용 간소화)
        function extractFeatures(canvas, ctx) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 기본 특징 계산
            let brightness = 0;
            let rSum = 0, gSum = 0, bSum = 0;
            let edgeCount = 0;
            
            const pixelCount = data.length / 4;
            
            // 픽셀 분석
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                brightness += (r + g + b) / 3;
                rSum += r;
                gSum += g;
                bSum += b;
            }
            
            // 색상 균일도 계산
            const avgR = rSum / pixelCount;
            const avgG = gSum / pixelCount;
            const avgB = bSum / pixelCount;
            
            let colorVariance = 0;
            for (let i = 0; i < data.length; i += 4) {
                colorVariance += Math.pow(data[i] - avgR, 2);
                colorVariance += Math.pow(data[i + 1] - avgG, 2);
                colorVariance += Math.pow(data[i + 2] - avgB, 2);
            }
            colorVariance = colorVariance / (pixelCount * 3);
            
            // 간단한 엣지 감지
            const threshold = 30;
            for (let y = 1; y < canvas.height - 1; y++) {
                for (let x = 1; x < canvas.width - 1; x++) {
                    const idx = (y * canvas.width + x) * 4;
                    const prevIdx = ((y - 1) * canvas.width + x) * 4;
                    
                    const diff = Math.abs(data[idx] - data[prevIdx]) + 
                                Math.abs(data[idx + 1] - data[prevIdx + 1]) + 
                                Math.abs(data[idx + 2] - data[prevIdx + 2]);
                    
                    if (diff > threshold * 3) edgeCount++;
                }
            }
            
            // 특징 정규화
            const features = {
                motion: Math.random() * 0.3, // 실제로는 이전 프레임과 비교 필요
                text: detectTextDensity(canvas, ctx),
                color: 1 - (colorVariance / 10000),
                edge: Math.min(edgeCount / (canvas.width * canvas.height * 0.1), 1),
                layout: detectLayoutScore(canvas, ctx),
                entropy: calculateEntropy(data),
                brightness: brightness / pixelCount / 255,
                timestamp: video.currentTime
            };
            
            return features;
        }
        
        // 텍스트 밀도 감지 (간소화)
        function detectTextDensity(canvas, ctx) {
            // 그레이스케일 변환
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const gray = new Uint8ClampedArray(imageData.data.length / 4);
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                gray[i / 4] = imageData.data[i] * 0.299 + 
                              imageData.data[i + 1] * 0.587 + 
                              imageData.data[i + 2] * 0.114;
            }
            
            // 텍스트 특성: 높은 대비 영역
            let textPixels = 0;
            for (let i = 1; i < gray.length - 1; i++) {
                if (Math.abs(gray[i] - gray[i - 1]) > 50) {
                    textPixels++;
                }
            }
            
            return Math.min(textPixels / gray.length * 10, 1);
        }
        
        // 레이아웃 점수 계산
        function detectLayoutScore(canvas, ctx) {
            // 수평/수직 라인 감지 (간소화)
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let horizontalLines = 0;
            let verticalLines = 0;
            
            // 샘플링으로 빠르게 검사
            const step = 10;
            
            // 수평선 검사
            for (let y = step; y < canvas.height - step; y += step) {
                let consecutivePixels = 0;
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;
                    const prevIdx = ((y - step) * canvas.width + x) * 4;
                    
                    const diff = Math.abs(data[idx] - data[prevIdx]) + 
                                Math.abs(data[idx + 1] - data[prevIdx + 1]) + 
                                Math.abs(data[idx + 2] - data[prevIdx + 2]);
                    
                    if (diff < 30) {
                        consecutivePixels++;
                        if (consecutivePixels > canvas.width * 0.5) {
                            horizontalLines++;
                            break;
                        }
                    } else {
                        consecutivePixels = 0;
                    }
                }
            }
            
            return Math.min((horizontalLines + verticalLines) / 20, 1);
        }
        
        // 엔트로피 계산
        function calculateEntropy(data) {
            const histogram = new Array(256).fill(0);
            
            for (let i = 0; i < data.length; i += 4) {
                const gray = Math.floor(data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114);
                histogram[gray]++;
            }
            
            const total = data.length / 4;
            let entropy = 0;
            
            for (let i = 0; i < 256; i++) {
                if (histogram[i] > 0) {
                    const p = histogram[i] / total;
                    entropy -= p * Math.log2(p);
                }
            }
            
            return entropy / 8; // 정규화
        }
        
        // 특징 시각화 업데이트
        function updateFeatureVisualization(features) {
            const cells = ['motion', 'text', 'color', 'edge', 'layout', 'entropy'];
            
            cells.forEach(cellId => {
                const cell = document.getElementById(cellId);
                const value = features[cellId];
                const valueElement = cell.querySelector('.value');
                
                // 값 표시
                valueElement.textContent = (value * 100).toFixed(1) + '%';
                
                // 색상 코딩
                cell.classList.remove('high', 'medium', 'low');
                if (value > 0.7) {
                    cell.classList.add('high');
                } else if (value > 0.4) {
                    cell.classList.add('medium');
                } else {
                    cell.classList.add('low');
                }
            });
        }
        
        // UI로 표시
        function markAsUI() {
            if (!currentFrame) {
                alert('먼저 비디오를 분석해주세요.');
                return;
            }
            
            saveSample(true);
        }
        
        // 게임으로 표시
        function markAsGame() {
            if (!currentFrame) {
                alert('먼저 비디오를 분석해주세요.');
                return;
            }
            
            saveSample(false);
        }
        
        // 샘플 저장
        function saveSample(isUI) {
            const sample = {
                id: Date.now(),
                timestamp: currentFrame.timestamp,
                features: currentFrame.features,
                isUI: isUI,
                thumbnail: currentFrame.canvas.toDataURL('image/jpeg', 0.5),
                createdAt: new Date().toISOString()
            };
            
            collectedSamples.push(sample);
            
            // 특징과 레이블 추가
            features.push(Object.values(currentFrame.features).slice(0, -1)); // timestamp 제외
            labels.push(isUI ? 1 : 0);
            
            updateStats();
            updateSampleGrid();
            addTimelineMarker(sample.timestamp, isUI);
            
            // 자동 저장
            if (collectedSamples.length % 10 === 0) {
                saveToLocalStorage();
            }
        }
        
        // 통계 업데이트
        function updateStats() {
            const total = collectedSamples.length;
            const uiCount = collectedSamples.filter(s => s.isUI).length;
            const gameCount = total - uiCount;
            
            document.getElementById('totalSamples').textContent = total;
            document.getElementById('uiSamples').textContent = uiCount;
            document.getElementById('gameSamples').textContent = gameCount;
            
            // 모델 상태 업데이트
            if (total >= 20) {
                document.getElementById('modelStatus').textContent = 
                    `${total}개 샘플 수집됨. 학습 준비 완료!`;
            }
        }
        
        // 샘플 그리드 업데이트
        function updateSampleGrid() {
            const grid = document.getElementById('sampleGrid');
            const recentSamples = collectedSamples.slice(-12);
            
            grid.innerHTML = recentSamples.map(sample => `
                <div class="sample-thumb" onclick="seekToTime(${sample.timestamp})">
                    <canvas id="thumb-${sample.id}"></canvas>
                    <span class="sample-label ${sample.isUI ? 'ui' : 'game'}">
                        ${sample.isUI ? 'UI' : 'GAME'}
                    </span>
                </div>
            `).join('');
            
            // 썸네일 그리기
            recentSamples.forEach(sample => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.getElementById(`thumb-${sample.id}`);
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        canvas.width = 160;
                        canvas.height = 90;
                        ctx.drawImage(img, 0, 0, 160, 90);
                    }
                };
                img.src = sample.thumbnail;
            });
        }
        
        // 모델 학습 (TensorFlow.js)
        async function trainModel() {
            if (features.length < 20) {
                alert('최소 20개 이상의 샘플이 필요합니다.');
                return;
            }
            
            document.getElementById('modelStatus').textContent = '모델 학습 중...';
            
            try {
                // 데이터 준비
                const xs = tf.tensor2d(features);
                const ys = tf.tensor1d(labels);
                
                // 모델 생성
                model = tf.sequential({
                    layers: [
                        tf.layers.dense({
                            inputShape: [features[0].length],
                            units: 16,
                            activation: 'relu'
                        }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({
                            units: 8,
                            activation: 'relu'
                        }),
                        tf.layers.dense({
                            units: 1,
                            activation: 'sigmoid'
                        })
                    ]
                });
                
                // 모델 컴파일
                model.compile({
                    optimizer: 'adam',
                    loss: 'binaryCrossentropy',
                    metrics: ['accuracy']
                });
                
                // 학습
                const history = await model.fit(xs, ys, {
                    epochs: 50,
                    validationSplit: 0.2,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            if (epoch % 10 === 0) {
                                document.getElementById('modelStatus').textContent = 
                                    `학습 중... Epoch ${epoch}/50, 정확도: ${(logs.acc * 100).toFixed(1)}%`;
                            }
                        }
                    }
                });
                
                // 최종 정확도
                const finalAccuracy = history.history.acc[history.history.acc.length - 1];
                document.getElementById('modelStatus').textContent = 
                    `학습 완료! 정확도: ${(finalAccuracy * 100).toFixed(1)}%`;
                
                // 특징 중요도 표시 (간소화)
                showFeatureImportance();
                
                // 정리
                xs.dispose();
                ys.dispose();
                
                // 학습 결과 표시 및 다음 단계 안내
                showTrainingResults(finalAccuracy);
                
            } catch (error) {
                console.error('모델 학습 오류:', error);
                alert('모델 학습 중 오류가 발생했습니다.');
            }
        }
        
        // 학습 결과 표시 및 스마트 모드 종료
        function showTrainingResults(accuracy) {
            // 결과 섹션에 상세 정보 표시
            const resultsDiv = document.getElementById('results');
            
            // UI 세그먼트 분석
            const uiSegments = analyzeUISegments();
            const hands = detectHandsFromUISegments(uiSegments);
            
            resultsDiv.innerHTML = `
                <div class="alert success">
                    <h3>✅ 모델 학습 완료!</h3>
                    <p><strong>학습 정확도:</strong> ${(accuracy * 100).toFixed(1)}%</p>
                    <p><strong>학습 샘플 수:</strong> ${collectedSamples.length}개 (UI: ${collectedSamples.filter(s => s.isUI).length}개, 게임: ${collectedSamples.filter(s => !s.isUI).length}개)</p>
                </div>
                
                <div class="section" style="margin-top: 20px;">
                    <h4>📊 UI 세그먼트 분석 결과</h4>
                    <p><strong>감지된 UI 구간:</strong> ${uiSegments.length}개</p>
                    <div style="max-height: 200px; overflow-y: auto;">
                        ${uiSegments.map((seg, i) => `
                            <div style="background: #0f3460; padding: 10px; margin: 5px 0; border-radius: 5px;">
                                <strong>UI ${i + 1}:</strong> ${formatTime(seg.start)} - ${formatTime(seg.end)} (${Math.floor(seg.duration)}초)
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div class="section" style="margin-top: 20px;">
                    <h4>🃏 핸드 분리 결과</h4>
                    <p><strong>예상 핸드 수:</strong> ${hands.length}개</p>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${hands.map((hand, i) => `
                            <div style="background: #0f3460; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 4px solid #3498db;">
                                <h5>핸드 ${i + 1}</h5>
                                <p><strong>시작:</strong> ${formatTime(hand.start)}</p>
                                <p><strong>종료:</strong> ${formatTime(hand.end)}</p>
                                <p><strong>길이:</strong> ${Math.floor(hand.duration)}초</p>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div class="alert" style="margin-top: 20px;">
                    <h4>🎯 다음 단계</h4>
                    <p>1. 학습 데이터를 내보내기하여 저장하세요</p>
                    <p>2. 다른 영상에서도 동일한 과정을 반복하여 더 많은 데이터를 수집하세요</p>
                    <p>3. 충분한 데이터가 모이면 더 정확한 핸드 분리가 가능합니다</p>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn success" onclick="exportData()">
                        📥 학습 데이터 내보내기
                    </button>
                    <button class="btn" onclick="finishSmartMode()">
                        🏁 스마트 모드 종료
                    </button>
                </div>
            `;
            
            // 분석 중지
            stopAnalysis();
        }
        
        // UI 세그먼트 분석
        function analyzeUISegments() {
            const uiSamples = collectedSamples.filter(s => s.isUI).sort((a, b) => a.timestamp - b.timestamp);
            const segments = [];
            
            if (uiSamples.length === 0) return segments;
            
            let currentSegment = { start: uiSamples[0].timestamp, end: uiSamples[0].timestamp };
            
            for (let i = 1; i < uiSamples.length; i++) {
                // 15초 이내 간격이면 같은 세그먼트
                if (uiSamples[i].timestamp - currentSegment.end < 15) {
                    currentSegment.end = uiSamples[i].timestamp;
                } else {
                    // 새로운 세그먼트 시작
                    if (currentSegment.end - currentSegment.start >= 15) {
                        segments.push({
                            start: currentSegment.start,
                            end: currentSegment.end,
                            duration: currentSegment.end - currentSegment.start
                        });
                    }
                    currentSegment = { start: uiSamples[i].timestamp, end: uiSamples[i].timestamp };
                }
            }
            
            // 마지막 세그먼트 처리
            if (currentSegment.end - currentSegment.start >= 15) {
                segments.push({
                    start: currentSegment.start,
                    end: currentSegment.end,
                    duration: currentSegment.end - currentSegment.start
                });
            }
            
            return segments;
        }
        
        // UI 세그먼트로부터 핸드 감지
        function detectHandsFromUISegments(uiSegments) {
            const hands = [];
            
            if (uiSegments.length === 0) return hands;
            
            // 첫 번째 핸드 (영상 시작 ~ 첫 UI)
            if (uiSegments[0].start > 15) {
                hands.push({
                    start: 0,
                    end: uiSegments[0].start - 15,
                    duration: uiSegments[0].start - 15
                });
            }
            
            // 중간 핸드들
            for (let i = 0; i < uiSegments.length - 1; i++) {
                const handStart = uiSegments[i].end + 15;
                const handEnd = uiSegments[i + 1].start - 15;
                
                if (handEnd > handStart && handEnd - handStart > 30) {
                    hands.push({
                        start: handStart,
                        end: handEnd,
                        duration: handEnd - handStart
                    });
                }
            }
            
            // 마지막 핸드
            const lastUI = uiSegments[uiSegments.length - 1];
            if (video.duration && video.duration - lastUI.end > 30) {
                hands.push({
                    start: lastUI.end + 15,
                    end: video.duration,
                    duration: video.duration - (lastUI.end + 15)
                });
            }
            
            return hands;
        }
        
        // 스마트 모드 종료
        function finishSmartMode() {
            if (confirm('스마트 모드를 종료하시겠습니까? 저장하지 않은 데이터는 사라집니다.')) {
                // 페이지 새로고침으로 초기화
                location.reload();
            }
        }
        
        // 시간 포맷
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // UI 예측
        async function predictUI(frameFeatures) {
            if (!model) return;
            
            const input = tf.tensor2d([Object.values(frameFeatures).slice(0, -1)]);
            const prediction = await model.predict(input).data();
            input.dispose();
            
            const uiProbability = prediction[0];
            
            // 예측 결과 표시
            if (uiProbability > 0.7) {
                document.getElementById('results').innerHTML = 
                    `<div class="alert success">🎯 UI 감지됨 (${(uiProbability * 100).toFixed(1)}% 확률)</div>`;
            }
        }
        
        // 특징 중요도 표시
        function showFeatureImportance() {
            const featureNames = ['motion', 'text', 'color', 'edge', 'layout', 'entropy', 'brightness'];
            const importanceScores = featureNames.map(() => Math.random() * 0.3 + 0.5); // 실제로는 모델에서 계산
            
            const container = document.getElementById('featureImportance');
            container.innerHTML = '<h4>📊 특징 중요도</h4>' + 
                featureNames.map((name, i) => `
                    <div class="feature-bar">
                        <span class="feature-name">${name}</span>
                        <div class="feature-score">
                            <div class="feature-score-fill" style="width: ${importanceScores[i] * 100}%"></div>
                        </div>
                    </div>
                `).join('');
        }
        
        // 진행률 업데이트
        function updateProgress() {
            if (!video.duration) return;
            
            const progress = (video.currentTime / video.duration) * 100;
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = progress + '%';
            progressBar.textContent = progress.toFixed(1) + '%';
            
            // 타임라인 커서
            document.getElementById('timelineCursor').style.left = progress + '%';
        }
        
        // 타임라인 초기화
        function initializeTimeline() {
            // 기존 마커 제거
            const timeline = document.getElementById('timeline');
            timeline.querySelectorAll('.timeline-segment').forEach(el => el.remove());
        }
        
        // 타임라인 마커 추가
        function addTimelineMarker(timestamp, isUI) {
            const timeline = document.getElementById('timeline');
            const position = (timestamp / video.duration) * 100;
            
            const marker = document.createElement('div');
            marker.className = 'timeline-segment';
            marker.style.left = position + '%';
            marker.style.width = '2px';
            marker.style.background = isUI ? '#e74c3c' : '#3498db';
            
            timeline.appendChild(marker);
        }
        
        // 타임라인 클릭
        function handleTimelineClick(e) {
            const rect = e.currentTarget.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percentage = x / rect.width;
            video.currentTime = video.duration * percentage;
        }
        
        // 특정 시간으로 이동
        function seekToTime(timestamp) {
            video.currentTime = timestamp;
        }
        
        // 탭 전환
        function showTab(tabName) {
            // 탭 버튼 업데이트
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // 탭 컨텐츠 업데이트
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + 'Tab').classList.add('active');
        }
        
        // 데이터 내보내기
        function exportData() {
            const exportData = {
                version: '1.0',
                created: new Date().toISOString(),
                samples: collectedSamples.map(s => ({
                    ...s,
                    thumbnail: s.thumbnail.substring(0, 100) + '...' // 크기 줄이기
                })),
                features: features,
                labels: labels
            };
            
            const blob = new Blob([JSON.stringify(exportData)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ui_training_data_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // 데이터 가져오기
        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        // 데이터 병합
                        collectedSamples = [...collectedSamples, ...data.samples];
                        features = [...features, ...data.features];
                        labels = [...labels, ...data.labels];
                        
                        updateStats();
                        updateSampleGrid();
                        alert('데이터를 성공적으로 가져왔습니다!');
                    } catch (err) {
                        alert('데이터 가져오기 실패: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // 로컬 스토리지 저장
        function saveToLocalStorage() {
            try {
                const dataToSave = {
                    samples: collectedSamples.slice(-100), // 최근 100개만
                    features: features.slice(-100),
                    labels: labels.slice(-100),
                    lastSaved: new Date().toISOString()
                };
                
                localStorage.setItem('uiLearningData', JSON.stringify(dataToSave));
                
                // 알림
                const alert = document.createElement('div');
                alert.className = 'alert success';
                alert.textContent = '✅ 데이터가 브라우저에 저장되었습니다.';
                document.querySelector('.container').insertBefore(alert, document.querySelector('.main-grid'));
                setTimeout(() => alert.remove(), 3000);
                
            } catch (e) {
                console.warn('로컬 스토리지 저장 실패:', e);
            }
        }
        
        // 로컬 스토리지에서 로드
        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('uiLearningData');
                if (saved) {
                    const data = JSON.parse(saved);
                    collectedSamples = data.samples || [];
                    features = data.features || [];
                    labels = data.labels || [];
                    
                    updateStats();
                    
                    if (collectedSamples.length > 0) {
                        console.log(`로컬 스토리지에서 ${collectedSamples.length}개 샘플 로드됨`);
                    }
                }
            } catch (e) {
                console.warn('로컬 스토리지 로드 실패:', e);
            }
        }
        
        // 데이터 초기화
        function clearData() {
            if (confirm('모든 학습 데이터를 삭제하시겠습니까?')) {
                collectedSamples = [];
                features = [];
                labels = [];
                model = null;
                
                updateStats();
                document.getElementById('sampleGrid').innerHTML = '';
                document.getElementById('modelStatus').textContent = '최소 20개의 샘플이 필요합니다';
                
                localStorage.removeItem('uiLearningData');
                
                alert('모든 데이터가 초기화되었습니다.');
            }
        }
    </script>
</body>
</html>